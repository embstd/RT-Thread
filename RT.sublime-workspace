{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"min",
				"min"
			],
			[
				"led",
				"ledstate"
			],
			[
				"err",
				"err_times"
			],
			[
				"test",
				"test_times"
			],
			[
				"user",
				"user_cnt"
			],
			[
				"E",
				"RT_ERROR"
			],
			[
				"AT",
				"AT_NUM"
			],
			[
				"rt_uin",
				"rt_uint32_t"
			],
			[
				"rt",
				"rt_uint8_t"
			],
			[
				"RT",
				"RT_EOK"
			],
			[
				"RT_",
				"RT_EOK"
			],
			[
				"rt_i",
				"rt_int32_t"
			],
			[
				"la",
				"last_event"
			],
			[
				"add",
				"addr"
			],
			[
				"u",
				"uint32_t"
			],
			[
				"nu",
				"num_data"
			],
			[
				"stm",
				"stm32_i2c_check_timeout"
			],
			[
				"rt_",
				"rt_thread_delay"
			],
			[
				"i2",
				"i2c_err"
			],
			[
				"i2c",
				"i2c_priv_data"
			],
			[
				"ret",
				"ret"
			]
		]
	},
	"buffers":
	[
		{
			"file": "bsp/stm32f10x/ir_stm32.c",
			"settings":
			{
				"buffer_size": 7490,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/main.c.dump",
			"settings":
			{
				"buffer_size": 4027,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/Printf.c.dump",
			"settings":
			{
				"buffer_size": 4913,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/hw_config.c",
			"settings":
			{
				"buffer_size": 17285,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_endp.c",
			"settings":
			{
				"buffer_size": 4701,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_istr.c",
			"settings":
			{
				"buffer_size": 11358,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_prop.c",
			"settings":
			{
				"buffer_size": 13853,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_pwr.c",
			"settings":
			{
				"buffer_size": 7579,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_desc.c",
			"settings":
			{
				"buffer_size": 7169,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "Searching 2207 files for \"rt_thread_delay\"\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\mini2440\\application.c:\n  220  		rt_hw_led_on(LED2|LED3);\n  221  		rt_hw_led_off(LED1|LED4);\n  222: 		rt_thread_delay(100);\n  223  \n  224  		/* light off leds for one second */\n  225  		rt_hw_led_off(LED2|LED3);\n  226  		rt_hw_led_on(LED1|LED4);\n  227: 		rt_thread_delay(100);\n  228  	}\n  229  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\mini2440\\dm9000.c:\n  278  		{\n  279  			/* autonegation complete bit */\n  280: 			rt_thread_delay( RT_TICK_PER_SECOND/10 );\n  281  			i++;\n  282  			if (i > 30 ) /* wait 3s */\n  ...\n  540  				/* RESET device */\n  541  				dm9000_io_write(DM9000_NCR, NCR_RST);\n  542: 				rt_thread_delay(1); /* delay 5ms */\n  543  			}\n  544  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\application.c:\n   83      		{\n   84      			LED1_ON();\n   85:     			rt_thread_delay(RT_TICK_PER_SECOND/2);\n   86      			LED1_OFF();\n   87:     			rt_thread_delay(RT_TICK_PER_SECOND/2);\n   88      		}\n   89      		LED1_ON();\n   ..\n  106  		//LED2_ON();\n  107  		//MOT_ON();\n  108: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  109  		//LED2_OFF();\n  110  		//MOT_OFF();\n  111: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  112  \n  113      }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\dm9000a.c:\n  290  	    {\n  291  	        /* autonegation complete bit */\n  292: 	        rt_thread_delay(10);\n  293  	        i++;\n  294  	        if (i == 10000)\n  ...\n  554                  /* RESET device */\n  555                  dm9000_io_write(DM9000_NCR, NCR_RST);\n  556:                 rt_thread_delay(1); /* delay 5ms */\n  557              }\n  558  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\i2c-stm32.c:\n   47        return RT_EOK;    \n   48      }\n   49:     //rt_thread_delay(RT_TICK_PER_SECOND/4); /* sleep 0.25 second and switch to other thread */\n   50    }\n   51    last_event=I2C_GetLastEvent(I2Cx);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\ili_lcd_general.c:\n  699          GPIO_SetBits(GPIOF,GPIO_Pin_10);\n  700          /* wait for lcd reset */\n  701:         rt_thread_delay(1);\n  702      }\n  703  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\ir_stm32.c:\n  219             check_ir_key(IR_Key);\n  220             LED2_ON();\n  221:            rt_thread_delay(RT_TICK_PER_SECOND/2);\n  222             LED2_OFF();\n  223             //check_pluse_array(PluseInd);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\ssd1289.c:\n  492          GPIO_SetBits(GPIOF,GPIO_Pin_10);\n  493          /* wait for lcd reset */\n  494:         rt_thread_delay(1);\n  495      }\n  496  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\test.c:\n  122  		PWRKEY_OFF();  \n  123  		PWRKEY_ON();\n  124: 		rt_thread_delay(RT_TICK_PER_SECOND*2);\n  125  		PWRKEY_OFF(); \n  126  	}\n  ...\n  129  		PWRKEY_OFF(); \n  130  		PWRKEY_ON(); \n  131: 		rt_thread_delay(RT_TICK_PER_SECOND*10);\n  132  		PWRKEY_OFF(); \n  133  	}\n  ...\n  136  		PWRKEY_OFF();\n  137  		PWRKEY_ON();\n  138: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  139  		PWRKEY_OFF();\n  140  	}\n  ...\n  159          if(test_ret>0)\n  160          {\n  161:             rt_thread_delay(RT_TICK_PER_SECOND/4);\n  162          }\n  163          else\n  164          {\n  165:             rt_thread_delay(RT_TICK_PER_SECOND*3);\n  166          }\n  167      }\n  ...\n  204  // Delay 1 Min\n  205      for(i=0; i<60; i++)\n  206:         rt_thread_delay(RT_TICK_PER_SECOND);\n  207  \n  208  //Check IO is 3.3V\n  ...\n  218  //Long powerkey shutdown sys\n  219      A10_PWR_CTL(A10_PWRSHUTDOWN);\n  220:     rt_thread_delay(RT_TICK_PER_SECOND*2);\n  221  \n  222  //Check IO is 0V\n  ...\n  231          do\n  232          {\n  233:             rt_thread_delay(RT_TICK_PER_SECOND);\n  234  //Check IO is 0.8-1.8V\n  235              if(check_io_voltage(f_adc)!=-1)\n  ...\n  251      check_io_voltage(f_adc);\n  252  }\n  253: rt_thread_delay(RT_TICK_PER_SECOND/2);\n  254  \n  255  }\n  ...\n  291      		//To suspend\n  292      		A10_PWR_CTL(A10_SUSPEND);\n  293:     		rt_thread_delay(RT_TICK_PER_SECOND*20);\n  294      		//Check is suspend state.\n  295      		if (Is_suspend())\n  ...\n  311      		// OK, now is suspend. Pls sleep 1 min\n  312      		rt_kprintf(\"Test suspend....: Now is suspend state and delay 1 min\\n\");\n  313:     		rt_thread_delay(RT_TICK_PER_SECOND*20);\n  314  l_resume:\n  315      		//To resume\n  316      		rt_kprintf(\"Test suspend....: resume state=%d and delay 20 sec\\n\", state);\n  317      		A10_PWR_CTL(A10_SUSPEND);\n  318:     		rt_thread_delay(RT_TICK_PER_SECOND*20);\n  319      		//Check is resume state.\n  320      		if (!Is_suspend())\n  ...\n  328      		// OK, now is resume. Pls sleep 1 min\n  329      		rt_kprintf(\"Test resume....: Now is resume state and delay 1 min\\n\");\n  330:     		rt_thread_delay(RT_TICK_PER_SECOND*20);    		\n  331  \n  332      	}\n  333  \n  334: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  335  \n  336      }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\touch.c:\n  487      rtgui_server_post_event(&emouse.parent, sizeof(struct rtgui_event_mouse));\n  488  \n  489:     rt_thread_delay(2) ;\n  490      emouse.button = (RTGUI_MOUSE_BUTTON_LEFT |RTGUI_MOUSE_BUTTON_UP );\n  491      rtgui_server_post_event(&emouse.parent, sizeof(struct rtgui_event_mouse));\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\applications\\application.c:\n   90  \n   91          /* Insert delay */\n   92:         rt_thread_delay(RT_TICK_PER_SECOND/2);\n   93          f_var3 += f_var4;\n   94          f_var4 = f_var4 * f_var4;\n   ..\n   98  \n   99          /* Insert delay */\n  100:         rt_thread_delay(RT_TICK_PER_SECOND/2);\n  101          f_var3 += f_var4;\n  102          f_var4 = f_var4 * f_var4;\n  ...\n  106  \n  107          /* Insert delay */\n  108:         rt_thread_delay(RT_TICK_PER_SECOND/2);\n  109          f_var3 += f_var4;\n  110          f_var4 = f_var4 * f_var4;\n  ...\n  114  \n  115          /* Insert delay */\n  116:         rt_thread_delay(RT_TICK_PER_SECOND*2);\n  117          f_var3 += f_var4;\n  118          f_var4 = f_var4 * f_var4;\n  ...\n  121  \n  122          /* Insert delay */\n  123:         rt_thread_delay(RT_TICK_PER_SECOND);\n  124          f_var3 += f_var4;\n  125          f_var4 = f_var4 * f_var4;\n  ...\n  141          sprintf(str_buffer, \"%f\", f_var_me);\n  142          rt_kprintf(\"thread1 %s\\r\\n\", str_buffer);\n  143:         rt_thread_delay(RT_TICK_PER_SECOND);\n  144      }\n  145  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\CMSIS\\RTOS\\cmsis_rtthread.c:\n  105  \n  106  	ticks = rt_tick_from_millisecond(millisec);\n  107: 	result = rt_thread_delay(ticks);\n  108  \n  109  	if (result == RT_EOK)\n  ...\n  120  \n  121  	ticks = rt_tick_from_millisecond(millisec);\n  122: 	result = rt_thread_delay(ticks);\n  123  /*\n  124  	if (result == RT_EOK)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\i2c\\i2c-bit-ops.c:\n   57          if ((rt_tick_get() - start) > ops->timeout)\n   58              return -RT_ETIMEOUT;\n   59:         rt_thread_delay((ops->timeout + 1) >> 1);\n   60      }\n   61  #ifdef RT_I2C_BIT_DEBUG\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\include\\drivers\\mmcsd_host.h:\n  116  	if (ms < 1000 / RT_TICK_PER_SECOND) \n  117  	{\n  118: 		rt_thread_delay(1);\n  119  	} \n  120  	else \n  121  	{\n  122: 		rt_thread_delay(ms/(1000 / RT_TICK_PER_SECOND));\n  123  	}\n  124  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\usb\\usbhost\\core\\core.c:\n  281          timeout) != 0) return -RT_EIO;\n  282  \n  283:     rt_thread_delay(50);\n  284  \n  285      uinst->address = uinst->index;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\usb\\usbhost\\core\\hub.c:\n  216      RT_ASSERT(uhub != RT_NULL);\n  217      \n  218:     rt_thread_delay(50);\n  219  \n  220      /* reset hub port */\n  ...\n  232      if(ret != RT_EOK) return ret;\n  233  \n  234:     rt_thread_delay(50);    \n  235  \n  236      return RT_EOK;\n  ...\n  266          }\n  267          \n  268:         rt_thread_delay(1);\n  269      }        \n  270  \n  ...\n  443      {\n  444          rt_usb_hub_set_port_feature(uhub, i + 1, PORT_FEAT_POWER);\n  445:         rt_thread_delay(uhub->hub_desc.pwron_to_good\n  446              * 2 * RT_TICK_PER_SECOND / 1000 );\n  447      }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\apps\\ping.c:\n  165  		if (send_time >= time) break; /* send ping times reached, stop */\n  166  \n  167: 		rt_thread_delay(PING_DELAY); /* take a delay */\n  168  	}\n  169  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\apps\\ping.c:\n  165  		if (send_time >= time) break; /* send ping times reached, stop */\n  166  \n  167: 		rt_thread_delay(PING_DELAY); /* take a delay */\n  168  	}\n  169  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\uip\\rt-thread\\uIPmain.c:\n   71      while(1)\n   72      {\n   73:         rt_thread_delay(CLOCK_SECOND*5);\n   74          for (i = 0; i < UIP_CONNS; i++) \n   75          {\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\utilities\\zmodem\\rz.c:\n   78  	rt_free(zf);\n   79  	/* waiting,clear console buffer */\n   80: 	rt_thread_delay(RT_TICK_PER_SECOND/2);\n   81  	while(1)                     \n   82  	{\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\utilities\\zmodem\\zdevice.c:\n   92  			 continue;\n   93  		case '\\335':\n   94: 		     rt_thread_delay(RT_TICK_PER_SECOND);\n   95  			 continue;\n   96  		default:\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\event_simple.c:\n   34  \n   35  		rt_kprintf(\"thread1: delay 1s to prepare second event\\n\");\n   36: 		rt_thread_delay(10);\n   37  \n   38  		/* receive second event */\n   ..\n   44  		}\n   45  \n   46: 		rt_thread_delay(5);\n   47  	}\n   48  }\n   ..\n   56  		rt_event_send(&event, (1 << 3));\n   57  \n   58: 		rt_thread_delay(10);\n   59  	}\n   60  }\n   ..\n   68  		rt_event_send(&event, (1 << 5));\n   69  \n   70: 		rt_thread_delay(20);\n   71  	}\n   72  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\mbox_send_wait.c:\n   33  \n   34  			/* 延时20个OS Tick */\n   35: 			rt_thread_delay(50);\n   36  		}\n   37  	}\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\mbox_simple.c:\n   35  \n   36  			/* 延时10个OS Tick */\n   37: 			rt_thread_delay(10);\n   38  		}\n   39  	}\n   ..\n   61  \n   62  		/* 延时20个OS Tick */\n   63: 		rt_thread_delay(20);\n   64  	}\n   65  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\memp_simple.c:\n   65  \n   66  		/* 休眠10个OS Tick */\n   67: 		rt_thread_delay(10);\n   68  	}\n   69  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\messageq_simple.c:\n   34  \n   35  		/* 延迟10个OS Tick */\n   36: 		rt_thread_delay(10);\n   37  	}\n   38  }\n   ..\n   57  				/* 消息队列满， 延迟1s时间 */\n   58  				rt_kprintf(\"message queue full, delay 1s\\n\");\n   59: 				rt_thread_delay(100);\n   60  			}\n   61  		}\n   62  \n   63  		/* 延时10个OS Tick */\n   64: 		rt_thread_delay(10);\n   65  	}\n   66  }\n   ..\n   79  \n   80  		/* 延时25个OS Tick */\n   81: 		rt_thread_delay(25);\n   82  	}\n   83  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\mutex_simple.c:\n   15  {\n   16  	/* 先让低优先级线程运行 */\n   17: 	rt_thread_delay(10);\n   18  \n   19  	/* 此时thread3持有mutex，并且thread2等待持有mutex */\n   ..\n   34  \n   35  	/* 先让低优先级线程运行 */\n   36: 	rt_thread_delay(5);\n   37  \n   38  	while (1)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\semaphore_buffer_worker.c:\n  155  \n  156  		/* 做一个5 OS Tick的休眠 */\n  157: 		rt_thread_delay(5);\n  158  	}\n  159  }\n  ...\n  185  \n  186  		/* 放入成功，做一个10 OS Tick的休眠 */\n  187: 		rt_thread_delay(10);\n  188  	}\n  189  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\semaphore_priority.c:\n   43  static void worker_thread_entry(void* parameter)\n   44  {\n   45: 	rt_thread_delay(10);\n   46  \n   47  	while (1)\n   48  	{\n   49  		rt_sem_release(sem);\n   50: 		rt_thread_delay(5);\n   51  	}\n   52  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\semaphore_producer_consumer.c:\n   45  \n   46  		/* 暂停一段时间 */\n   47: 		rt_thread_delay(50);\n   48  	}\n   49  \n   ..\n   79  \n   80  		/* 暂停一小会时间 */\n   81: 		rt_thread_delay(10);\n   82  	}\n   83  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\tc_comm.c:\n   79  	_tc_stat &= ~TC_STAT_RUNNING;\n   80  \n   81: 	rt_thread_delay(RT_TICK_PER_SECOND/2);\n   82  	if (_tc_thread.stat != RT_THREAD_INIT)\n   83  	{\n   ..\n   92  		rt_exit_critical();\n   93  	}\n   94: 	rt_thread_delay(RT_TICK_PER_SECOND/2);\n   95  }\n   96  FINSH_FUNCTION_EXPORT(tc_stop, stop testcase thread);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_delay.c:\n   14  	rt_kprintf(\"thread delay 10 tick\\n\");\n   15  	tick = rt_tick_get();\n   16: 	rt_thread_delay(10);\n   17  	if (rt_tick_get() - tick > 10)\n   18  	{\n   ..\n   23  	rt_kprintf(\"thread delay 15 tick\\n\");\n   24  	tick = rt_tick_get();\n   25: 	rt_thread_delay(15);\n   26  	if (rt_tick_get() - tick > 15)\n   27  	{\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_delete.c:\n   42  \n   43  	/* 线程2启动后先睡眠10个OS Tick */\n   44: 	rt_thread_delay(10);\n   45  \n   46  	/*\n   ..\n   54  	 * idle线程将执行真正的线程1控制块和线程栈的删除\n   55  	 */\n   56: 	rt_thread_delay(10);\n   57  }\n   58  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_detach.c:\n   34  \n   35  	/* 线程2启动后先睡眠10个OS Tick */\n   36: 	rt_thread_delay(10);\n   37  \n   38  	/*\n   ..\n   44  	 * 线程2继续休眠10个OS Tick然后退出\n   45  	 */\n   46: 	rt_thread_delay(10);\n   47  \n   48  	/*\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_dynamic.c:\n    5  {\n    6  	rt_kprintf(\"thread dynamicly created ok\\n\");\n    7: 	rt_thread_delay(10);\n    8  	rt_kprintf(\"thread exit\\n\");\n    9  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_dynamic_simple.c:\n   22  \n   23  		/* 休眠10个OS Tick */\n   24: 		rt_thread_delay(10);\n   25  	}\n   26  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_priority.c:\n   18  		rt_kprintf(\"count = %d\\n\", count);\n   19  \n   20: 		rt_thread_delay(10);\n   21  	}\n   22  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_resume.c:\n   42  {\n   43  	/* 延时10个OS Tick */\n   44: 	rt_thread_delay(10);\n   45  \n   46  	/* 唤醒线程1 */\n   ..\n   49  \n   50  	/* 延时10个OS Tick */\n   51: 	rt_thread_delay(10);\n   52  \n   53  	/* 线程2自动退出 */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_static.c:\n   10  {\n   11  	rt_kprintf(\"thread staticly inited ok\\n\");\n   12: 	rt_thread_delay(10);\n   13  	rt_kprintf(\"thread exit\\n\");\n   14  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_static_simple.c:\n   28  \n   29  		/* 休眠10个OS Tick */\n   30: 		rt_thread_delay(10);\n   31  	}\n   32  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_suspend.c:\n   26  {\n   27  	/* 延时10个OS Tick */\n   28: 	rt_thread_delay(10);\n   29  \n   30  	/* 挂起线程1 */\n   ..\n   32  \n   33  	/* 延时10个OS Tick */\n   34: 	rt_thread_delay(10);\n   35  \n   36  	/* 线程2自动退出 */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\network\\tcpsendpacket.c:\n   47  			rt_kprintf(\"TCP thread send error: %d\\n\", result);\n   48  			lwip_close(sock);	//¹Ø±ÕÁ¬½Ó£¬ÖØÐÂ´´½¨Á¬½Ó\n   49: 			rt_thread_delay(10);\n   50  			if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)\n   51  				rt_kprintf(\"TCP Socket error:%d\\n\",sock);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\network\\udpclient.c:\n   34  \n   35         /* 线程休眠一段时间 */\n   36:        rt_thread_delay(50);\n   37  \n   38         /* 计数值减一 */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\include\\rtthread.h:\n  136  \n  137  rt_err_t rt_thread_yield(void);\n  138: rt_err_t rt_thread_delay(rt_tick_t tick);\n  139  rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);\n  140  rt_err_t rt_thread_suspend(rt_thread_t thread);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\src\\thread.c:\n   19   * 2006-09-03     Bernard      implement rt_thread_detach\n   20   * 2008-02-16     Bernard      fixed the rt_thread_timeout bug\n   21:  * 2010-03-21     Bernard      change the errno of rt_thread_delay/sleep to\n   22   *                             RT_EOK.\n   23   * 2010-11-10     Bernard      add cleanup callback function in thread exit.\n   ..\n  447   * @return RT_EOK\n  448   */\n  449: rt_err_t rt_thread_delay(rt_tick_t tick)\n  450  {\n  451      return rt_thread_sleep(tick);\n  452  }\n  453: RTM_EXPORT(rt_thread_delay);\n  454  \n  455  /**\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\src\\timer.c:\n  551                  /* get the delta timeout tick */\n  552                  next_timeout = next_timeout - current_tick;\n  553:                 rt_thread_delay(next_timeout);\n  554              }\n  555          }\n\n94 matches across 46 files\n\n\nSearching 2207 files for \"delay\"\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\mini2440\\application.c:\n  220  		rt_hw_led_on(LED2|LED3);\n  221  		rt_hw_led_off(LED1|LED4);\n  222: 		rt_thread_delay(100);\n  223  \n  224  		/* light off leds for one second */\n  225  		rt_hw_led_off(LED2|LED3);\n  226  		rt_hw_led_on(LED1|LED4);\n  227: 		rt_thread_delay(100);\n  228  	}\n  229  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\mini2440\\dm9000.c:\n   60  void rt_dm9000_isr(int irqno);\n   61  \n   62: static void delay_ms(rt_uint32_t ms)\n   63  {\n   64  	rt_uint32_t len;\n   ..\n   90  	dm9000_io_write(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */\n   91  \n   92: 	delay_ms(100);		/* Wait read complete */\n   93  \n   94  	dm9000_io_write(DM9000_EPCR, 0x0);	/* Clear phyxcer read command */\n   ..\n  109  	dm9000_io_write(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */\n  110  \n  111: 	delay_ms(500);		/* Wait write complete */\n  112  \n  113  	dm9000_io_write(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */\n  ...\n  225  	/* RESET device */\n  226  	dm9000_io_write(DM9000_NCR, NCR_RST);\n  227: 	delay_ms(1000);		/* delay 1ms */\n  228  \n  229  	/* identfy DM9000 */\n  ...\n  278  		{\n  279  			/* autonegation complete bit */\n  280: 			rt_thread_delay( RT_TICK_PER_SECOND/10 );\n  281  			i++;\n  282  			if (i > 30 ) /* wait 3s */\n  ...\n  540  				/* RESET device */\n  541  				dm9000_io_write(DM9000_NCR, NCR_RST);\n  542: 				rt_thread_delay(1); /* delay 5ms */\n  543  			}\n  544  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\mini2440\\sdcard.c:\n   23  volatile rt_int32_t sd_type;\n   24  \n   25: static void sd_delay(rt_uint32_t ms)\n   26  {\n   27      ms *= 7326;\n   ..\n  190          }\n  191  \n  192:         sd_delay(200);\n  193      }\n  194      SDICSTA = 0xa00;\n  ...\n  263  \n  264      sd_sel_desel(1);\n  265:     sd_delay(200);\n  266      sd_setbus();\n  267  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\mini2440\\touch.c:\n   79  	int shift;\n   80  \n   81: 	int delay;\n   82  	int presc;\n   83  \n   ..\n  374  	rt_memset(&ts, 0, sizeof(struct s3c2410ts));\n  375  \n  376: 	ts.delay = 50000;\n  377  	ts.presc = 9;\n  378  	ts.shift = 2;\n  ...\n  381  \n  382  	ADCCON = S3C2410_ADCCON_PRSCEN | S3C2410_ADCCON_PRSCVL(ts.presc);\n  383: 	ADCDLY = ts.delay;\n  384  \n  385  	ADCTSC = WAIT4INT(0);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\application.c:\n   83      		{\n   84      			LED1_ON();\n   85:     			rt_thread_delay(RT_TICK_PER_SECOND/2);\n   86      			LED1_OFF();\n   87:     			rt_thread_delay(RT_TICK_PER_SECOND/2);\n   88      		}\n   89      		LED1_ON();\n   ..\n  106  		//LED2_ON();\n  107  		//MOT_ON();\n  108: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  109  		//LED2_OFF();\n  110  		//MOT_OFF();\n  111: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  112  \n  113      }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\dm9000a.c:\n   72  void rt_dm9000_isr(void);\n   73  \n   74: static void delay_ms(rt_uint32_t ms)\n   75  {\n   76      rt_uint32_t len;\n   ..\n  102      dm9000_io_write(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */\n  103  \n  104:     delay_ms(100);		/* Wait read complete */\n  105  \n  106      dm9000_io_write(DM9000_EPCR, 0x0);	/* Clear phyxcer read command */\n  ...\n  121      dm9000_io_write(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */\n  122  \n  123:     delay_ms(500);		/* Wait write complete */\n  124  \n  125      dm9000_io_write(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */\n  ...\n  239      /* RESET device */\n  240      dm9000_io_write(DM9000_NCR, NCR_RST);\n  241:     delay_ms(1000);		/* delay 1ms */\n  242  \n  243      /* identfy DM9000 */\n  ...\n  290  	    {\n  291  	        /* autonegation complete bit */\n  292: 	        rt_thread_delay(10);\n  293  	        i++;\n  294  	        if (i == 10000)\n  ...\n  554                  /* RESET device */\n  555                  dm9000_io_write(DM9000_NCR, NCR_RST);\n  556:                 rt_thread_delay(1); /* delay 5ms */\n  557              }\n  558  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\enc28j60.c:\n   38  static struct rt_semaphore lock_sem;\n   39  \n   40: void _delay_us(rt_uint32_t us)\n   41  {\n   42  	rt_uint32_t len;\n   ..\n   45  }\n   46  \n   47: void delay_ms(rt_uint32_t ms)\n   48  {\n   49  	rt_uint32_t len;\n   ..\n  157  	while(spi_read(MISTAT) & MISTAT_BUSY)\n  158  	{\n  159: 		_delay_us(15);\n  160  	}\n  161  }\n  ...\n  168  	spi_write(MICMD, MICMD_MIIRD);\n  169  \n  170: 	_delay_us(15);\n  171  \n  172  	// wait until the PHY read completes\n  ...\n  354  	// perform system reset\n  355  	spi_write_op(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);\n  356: 	delay_ms(50);\n  357  	NextPacketPtr = RXSTART_INIT;\n  358  \n  ...\n  445  \n  446  	enc28j60_phy_write(PHLCON, 0xD76);	//0x476\n  447: 	delay_ms(20);\n  448  \n  449      return RT_EOK;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\i2c-stm32.c:\n   47        return RT_EOK;    \n   48      }\n   49:     //rt_thread_delay(RT_TICK_PER_SECOND/4); /* sleep 0.25 second and switch to other thread */\n   50    }\n   51    last_event=I2C_GetLastEvent(I2Cx);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\ili_lcd_general.c:\n  144  }\n  145  \n  146: static void delay(int cnt)\n  147  {\n  148      volatile unsigned int dl;\n  ...\n  328          write_reg(0x0012,0x0000);\n  329          write_reg(0x0013,0x0000);\n  330:         delay(15);\n  331          write_reg(0x0010,0x1590);\n  332          write_reg(0x0011,0x0227);\n  333:         delay(15);\n  334          write_reg(0x0012,0x009c);\n  335:         delay(15);\n  336          write_reg(0x0013,0x1900);\n  337          write_reg(0x0029,0x0023);\n  338          write_reg(0x002b,0x000e);\n  339:         delay(15);\n  340          write_reg(0x0020,0x0000);\n  341          write_reg(0x0021,0x0000);\n  342:         delay(15);\n  343          write_reg(0x0030,0x0007);\n  344          write_reg(0x0031,0x0707);\n  ...\n  351          write_reg(0x003c,0x0701);\n  352          write_reg(0x003d,0x000f);\n  353:         delay(15);\n  354          write_reg(0x0050,0x0000);\n  355          write_reg(0x0051,0x00ef);\n  ...\n  400          write_reg(0x0f,0x0000);	//Extern Display Interface Contral 2.\n  401  \n  402:         delay(15);\n  403          write_reg(0x07,0x0101);	//Display Contral.\n  404:         delay(15);\n  405  \n  406          write_reg(0x10,(1<<12)|(0<<8)|(1<<7)|(1<<6)|(0<<4));	//Power Control 1.(0x16b0)\n  ...\n  452          write_reg(0x15,0x0050);\n  453          write_reg(0x12,0x0016);\n  454:         delay(15);\n  455          write_reg(0x10,0x5660);\n  456:         delay(15);\n  457          write_reg(0x13,0x2A4E);\n  458  #if defined(_ILI_REVERSE_DIRECTION_)\n  ...\n  478          write_reg(0x38,0x0208);\n  479          write_reg(0x39,0x0F0B);\n  480:         delay(15);\n  481          write_reg(0x41,0x0002);\n  482  \n  ...\n  493          write_reg(0xA0,0x0100);\n  494  //	    write_reg(0x07,0x0001);\n  495:         delay(15);\n  496  //	    write_reg(0x07,0x0021);\n  497:         delay(15);\n  498  //	    write_reg(0x07,0x0023);\n  499:         delay(15);\n  500  //	    write_reg(0x07,0x0033);\n  501:         delay(15);\n  502          write_reg(0x07,0x0133);\n  503:         delay(15);\n  504          write_reg(0xA0,0x0000);\n  505:         delay(20);\n  506      }\n  507      else if( deviceid ==0x7783)\n  ...\n  521          write_reg(0x0012,0x0000);\n  522          write_reg(0x0013,0x0000);\n  523:         delay(20);\n  524          write_reg(0x0010,0x12B0);\n  525:         delay(20);\n  526          write_reg(0x0011,0x0007);\n  527:         delay(20);\n  528          write_reg(0x0012,0x008B);\n  529:         delay(20);\n  530          write_reg(0x0013,0x1700);\n  531:         delay(20);\n  532          write_reg(0x0029,0x0022);\n  533  \n  ...\n  543          write_reg(0x003C,0x0202);\n  544          write_reg(0x003D,0x0408);\n  545:         delay(20);\n  546          write_reg(0x0050,0x0000);\n  547          write_reg(0x0051,0x00EF);\n  ...\n  553          write_reg(0x002B,0x000B);\n  554          write_reg(0x0007,0x0133);\n  555:         delay(20);\n  556      }\n  557  \n  ...\n  699          GPIO_SetBits(GPIOF,GPIO_Pin_10);\n  700          /* wait for lcd reset */\n  701:         rt_thread_delay(1);\n  702      }\n  703  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\ir_stm32.c:\n  219             check_ir_key(IR_Key);\n  220             LED2_ON();\n  221:            rt_thread_delay(RT_TICK_PER_SECOND/2);\n  222             LED2_OFF();\n  223             //check_pluse_array(PluseInd);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\\stm32f10x.h:\n 4989  #define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */\n 4990  \n 4991: #define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */\n 4992  #define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */\n 4993  #define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */\n ....\n 4995  #define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */\n 4996  \n 4997: #define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */\n 4998  #define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */\n 4999  #define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */\n ....\n 5017  #define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */\n 5018  \n 5019: #define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */\n 5020  #define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */\n 5021  #define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */\n ....\n 5023  #define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */\n 5024  \n 5025: #define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */\n 5026  #define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */\n 5027  #define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */\n ....\n 5045  #define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */\n 5046  \n 5047: #define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */\n 5048  #define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */\n 5049  #define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */\n ....\n 5051  #define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */\n 5052  \n 5053: #define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */\n 5054  #define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */\n 5055  #define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */\n ....\n 7896  #define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */\n 7897  #define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */\n 7898: #define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling\n 7899                                                         a transmission attempt during retries after a collision: 0 =< r <2^k */\n 7900    #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\Libraries\\STM32F10x_StdPeriph_Driver\\inc\\stm32f10x_fsmc.h:\n  199  \n  200    uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the\n  201:                                        delay between CLE low and RE low.\n  202                                         This parameter can be a value between 0 and 0xFF. */\n  203  \n  204    uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the\n  205:                                        delay between ALE low and RE low.\n  206                                         This parameter can be a number between 0x0 and 0xFF */ \n  207  \n  ...\n  221  \n  222    uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the\n  223:                                      delay between CLE low and RE low.\n  224                                       This parameter can be a value between 0 and 0xFF. */\n  225  \n  226    uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the\n  227:                                      delay between ALE low and RE low.\n  228                                       This parameter can be a number between 0x0 and 0xFF */ \n  229  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\Libraries\\STM32F10x_StdPeriph_Driver\\inc\\stm32f10x_tim.h:\n  149                                        This parameter can be a value of @ref Lock_level */ \n  150  \n  151:   uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the\n  152                                        switching-on of the outputs.\n  153                                        This parameter can be a number between 0x00 and 0xFF  */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_flash.c:\n   82  #define FLASH_BANK1_END_ADDRESS   ((uint32_t)0x807FFFF)\n   83  \n   84: /* Delay definition */   \n   85  #define EraseTimeout          ((uint32_t)0x000B0000)\n   86  #define ProgramTimeout        ((uint32_t)0x00002000)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\msd.c:\n  122    /* MSD chip select high */\n  123    MSD_CS_HIGH();\n  124:   /* Send dummy byte: 8 Clock pulses of delay */\n  125    MSD_WriteByte(DUMMY);\n  126    /* Returns the reponse */\n  ...\n  173    /* MSD chip select high */\n  174    MSD_CS_HIGH();\n  175:   /* Send dummy byte: 8 Clock pulses of delay */\n  176    MSD_WriteByte(DUMMY);\n  177    /* Returns the reponse */\n  ...\n  243    /* MSD chip select high */\n  244    MSD_CS_HIGH();\n  245:   /* Send dummy byte: 8 Clock pulses of delay */\n  246    MSD_WriteByte(DUMMY);\n  247    /* Returns the reponse */\n  ...\n  308    /* MSD chip select high */\n  309    MSD_CS_HIGH();\n  310:   /* Send dummy byte: 8 Clock pulses of delay */\n  311    MSD_WriteByte(DUMMY);\n  312    /* Returns the reponse */\n  ...\n  355    /* MSD chip select high */\n  356    MSD_CS_HIGH();\n  357:   /* Send dummy byte: 8 Clock pulses of delay */\n  358    MSD_WriteByte(DUMMY);\n  359  \n  ...\n  463    /* MSD chip select high */\n  464    MSD_CS_HIGH();\n  465:   /* Send dummy byte: 8 Clock pulses of delay */\n  466    MSD_WriteByte(DUMMY);\n  467  \n  ...\n  752  void SPI_Config(void)\n  753  {\n  754:   uint32_t delay;\n  755    GPIO_InitTypeDef  GPIO_InitStructure;\n  756    SPI_InitTypeDef   SPI_InitStructure;\n  ...\n  790    /* active SD card */\n  791    GPIO_ResetBits(GPIOD, GPIO_Pin_10);\n  792:   for (delay = 0; delay < 0xfffff; delay ++);\n  793  }\n  794  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\sdcard.c:\n 1751  {\n 1752    SD_Error errorstatus = SD_OK;\n 1753:   uint32_t delay = 0;\n 1754:   __IO uint32_t maxdelay = 0;\n 1755    uint8_t cardstate = 0;\n 1756  \n ....\n 1762    }\n 1763  \n 1764:   maxdelay = 72000 / ((SDIO->CLKCR & 0xFF) + 2);\n 1765  \n 1766    if (SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED)\n ....\n 1823    }\n 1824  \n 1825:   for (delay = 0; delay < maxdelay; delay++)\n 1826    {}\n 1827  \n ....\n 2803    SDIO_DataConfig(&SDIO_DataInitStructure);\n 2804  \n 2805:   /* make a delay */\n 2806    {\n 2807:     volatile uint32_t delay;\n 2808:     for(delay = 0; delay < 20; delay++);\n 2809    }\n 2810  \n ....\n 3171      GPIO_Init(GPIOC,&GPIO_InitStructure);\n 3172      GPIO_ResetBits(GPIOC,GPIO_Pin_6); /* SD card power up */\n 3173:     // delay same time for SD card power up\n 3174  \n 3175      if (SD_Init() == SD_OK)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\ssd1289.c:\n  145  }\n  146  \n  147: static void delay(int cnt)\n  148  {\n  149      volatile unsigned int dl;\n  ...\n  291      write_reg(0x0010,0x0000);\n  292      // Wait 30ms\n  293:     delay(3000);\n  294      // set R07h at 0033h (GON=1,DTE=1,D[1:0]=11)\n  295      write_reg(0x0007,0x0033);\n  ...\n  492          GPIO_SetBits(GPIOF,GPIO_Pin_10);\n  493          /* wait for lcd reset */\n  494:         rt_thread_delay(1);\n  495      }\n  496  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\stm3210c_eval_lcd.c:\n   52  	};\n   53  \n   54: static void _delay_(__IO uint32_t nCount)\n   55  {\n   56  	__IO uint32_t index = 0;\n   ..\n  252  	LCD_WriteReg(R18, 0x0000); /* VREG1OUT voltage */\n  253  	LCD_WriteReg(R19, 0x0000); /* VDV[4:0] for VCOM amplitude */\n  254: 	_delay_(20);                 /* Dis-charge capacitor power voltage (200ms) */\n  255  	LCD_WriteReg(R16, 0x17B0); /* SAP, BT[3:0], AP, DSTB, SLP, STB */\n  256  	LCD_WriteReg(R17, 0x0137); /* DC1[2:0], DC0[2:0], VC[2:0] */\n  257: 	_delay_(5);                  /* Delay 50 ms */\n  258  	LCD_WriteReg(R18, 0x0139); /* VREG1OUT voltage */\n  259: 	_delay_(5);                  /* delay 50 ms */\n  260  	LCD_WriteReg(R19, 0x1d00); /* VDV[4:0] for VCOM amplitude */\n  261  	LCD_WriteReg(R41, 0x0013); /* VCM[4:0] for VCOMH */\n  262: 	_delay_(5);                  /* delay 50 ms */\n  263  	LCD_WriteReg(R7, 0x0173);  /* 262K color and display ON */\n  264  }\n  ...\n  339  	/* Configure the LCD_SPI interface ----------------------------------------------*/\n  340  	LCD_SPIConfig();\n  341: 	_delay_(5); /* Delay 50 ms */\n  342  	/* Start Initial Sequence ------------------------------------------------*/\n  343  	LCD_WriteReg(R229, 0x8000); /* Set the internal vcore voltage */\n  ...\n  358  	LCD_WriteReg(R18, 0x0000); /* VREG1OUT voltage */\n  359  	LCD_WriteReg(R19, 0x0000); /* VDV[4:0] for VCOM amplitude */\n  360: 	_delay_(20);                 /* Dis-charge capacitor power voltage (200ms) */\n  361  	LCD_WriteReg(R16, 0x17B0); /* SAP, BT[3:0], AP, DSTB, SLP, STB */\n  362  	LCD_WriteReg(R17, 0x0137); /* DC1[2:0], DC0[2:0], VC[2:0] */\n  363: 	_delay_(5);                  /* Delay 50 ms */\n  364  	LCD_WriteReg(R18, 0x0139); /* VREG1OUT voltage */\n  365: 	_delay_(5);                  /* Delay 50 ms */\n  366  	LCD_WriteReg(R19, 0x1d00); /* VDV[4:0] for VCOM amplitude */\n  367  	LCD_WriteReg(R41, 0x0013); /* VCM[4:0] for VCOMH */\n  368: 	_delay_(5);                  /* Delay 50 ms */\n  369  	LCD_WriteReg(R32, 0x0000); /* GRAM horizontal Address */\n  370  	LCD_WriteReg(R33, 0x0000); /* GRAM Vertical Address */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\stm3210e_eval_lcd.c:\n  360  };\n  361  \n  362: #define Delay(v)									\\\n  363  	{												\\\n  364  		volatile  rt_uint32_t index;				\\\n  ...\n  375  	LCD_FSMCConfig();\n  376  \n  377: 	Delay(5); /* delay 50 ms */\n  378  	// Gamma for CMO 3.2¡±\n  379  	LCD_WriteReg(0x46,0x94);\n  ...\n  419  	LCD_WriteReg(0x3d,0x00);\n  420  \n  421: 	Delay(2);\n  422  \n  423  	LCD_WriteReg(0x35,0x38);\n  ...\n  433  	LCD_WriteReg(0x93,0x0f);//*******\n  434  \n  435: 	Delay(1);\n  436  \n  437  	LCD_WriteReg(0x20,0x30);\n  ...\n  443  	LCD_WriteReg(0x44,0x4d);//4d***************4f\n  444  	LCD_WriteReg(0x45,0x13);//0x0a);\n  445: 	Delay(1);\n  446  	LCD_WriteReg(0x1c,0x04);\n  447: 	Delay(2);\n  448  	LCD_WriteReg(0x43,0x80);\n  449: 	Delay(5);\n  450  	LCD_WriteReg(0x1b,0x08);\n  451: 	Delay(4);\n  452  	LCD_WriteReg(0x1b,0x10);\n  453: 	Delay(4);\n  454  \n  455  	// Display ON Setting\n  456  	LCD_WriteReg(0x90,0x7f);\n  457  	LCD_WriteReg(0x26,0x04);\n  458: 	Delay(4);\n  459  	LCD_WriteReg(0x26,0x24);\n  460  	LCD_WriteReg(0x26,0x2c);\n  461: 	Delay(4);\n  462  	LCD_WriteReg(0x26,0x3c);\n  463  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\test.c:\n  122  		PWRKEY_OFF();  \n  123  		PWRKEY_ON();\n  124: 		rt_thread_delay(RT_TICK_PER_SECOND*2);\n  125  		PWRKEY_OFF(); \n  126  	}\n  ...\n  129  		PWRKEY_OFF(); \n  130  		PWRKEY_ON(); \n  131: 		rt_thread_delay(RT_TICK_PER_SECOND*10);\n  132  		PWRKEY_OFF(); \n  133  	}\n  ...\n  136  		PWRKEY_OFF();\n  137  		PWRKEY_ON();\n  138: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  139  		PWRKEY_OFF();\n  140  	}\n  ...\n  159          if(test_ret>0)\n  160          {\n  161:             rt_thread_delay(RT_TICK_PER_SECOND/4);\n  162          }\n  163          else\n  164          {\n  165:             rt_thread_delay(RT_TICK_PER_SECOND*3);\n  166          }\n  167      }\n  ...\n  199      l_powerup:\n  200      state=0;\n  201:     rt_kprintf(\"Test IO ADC....: power up state=%d and delay 1 min\\n\", state);\n  202  //Power UP\n  203      A10_PWR_CTL(A10_PWRENUP);\n  204: // Delay 1 Min\n  205      for(i=0; i<60; i++)\n  206:         rt_thread_delay(RT_TICK_PER_SECOND);\n  207  \n  208  //Check IO is 3.3V\n  ...\n  215  \n  216      state=1;\n  217:     rt_kprintf(\"Test IO ADC....: power off state=%d and delay 10 sec\\n\", state);\n  218  //Long powerkey shutdown sys\n  219      A10_PWR_CTL(A10_PWRSHUTDOWN);\n  220:     rt_thread_delay(RT_TICK_PER_SECOND*2);\n  221  \n  222  //Check IO is 0V\n  ...\n  231          do\n  232          {\n  233:             rt_thread_delay(RT_TICK_PER_SECOND);\n  234  //Check IO is 0.8-1.8V\n  235              if(check_io_voltage(f_adc)!=-1)\n  ...\n  251      check_io_voltage(f_adc);\n  252  }\n  253: rt_thread_delay(RT_TICK_PER_SECOND/2);\n  254  \n  255  }\n  ...\n  288  l_suspend:\n  289      		state=0;\n  290:     		rt_kprintf(\"Test suspend....: suspend state=%d and delay 20 sec\\n\", state);\n  291      		//To suspend\n  292      		A10_PWR_CTL(A10_SUSPEND);\n  293:     		rt_thread_delay(RT_TICK_PER_SECOND*20);\n  294      		//Check is suspend state.\n  295      		if (Is_suspend())\n  ...\n  310  \n  311      		// OK, now is suspend. Pls sleep 1 min\n  312:     		rt_kprintf(\"Test suspend....: Now is suspend state and delay 1 min\\n\");\n  313:     		rt_thread_delay(RT_TICK_PER_SECOND*20);\n  314  l_resume:\n  315      		//To resume\n  316:     		rt_kprintf(\"Test suspend....: resume state=%d and delay 20 sec\\n\", state);\n  317      		A10_PWR_CTL(A10_SUSPEND);\n  318:     		rt_thread_delay(RT_TICK_PER_SECOND*20);\n  319      		//Check is resume state.\n  320      		if (!Is_suspend())\n  ...\n  327      		}\n  328      		// OK, now is resume. Pls sleep 1 min\n  329:     		rt_kprintf(\"Test resume....: Now is resume state and delay 1 min\\n\");\n  330:     		rt_thread_delay(RT_TICK_PER_SECOND*20);    		\n  331  \n  332      	}\n  333  \n  334: 		rt_thread_delay(RT_TICK_PER_SECOND/2);\n  335  \n  336      }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f10x\\touch.c:\n  487      rtgui_server_post_event(&emouse.parent, sizeof(struct rtgui_event_mouse));\n  488  \n  489:     rt_thread_delay(2) ;\n  490      emouse.button = (RTGUI_MOUSE_BUTTON_LEFT |RTGUI_MOUSE_BUTTON_UP );\n  491      rtgui_server_post_event(&emouse.parent, sizeof(struct rtgui_event_mouse));\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\applications\\application.c:\n   89          GPIO_SetBits(GPIOD, GPIO_Pin_12);\n   90  \n   91:         /* Insert delay */\n   92:         rt_thread_delay(RT_TICK_PER_SECOND/2);\n   93          f_var3 += f_var4;\n   94          f_var4 = f_var4 * f_var4;\n   ..\n   97          GPIO_SetBits(GPIOD, GPIO_Pin_13);\n   98  \n   99:         /* Insert delay */\n  100:         rt_thread_delay(RT_TICK_PER_SECOND/2);\n  101          f_var3 += f_var4;\n  102          f_var4 = f_var4 * f_var4;\n  ...\n  105          GPIO_SetBits(GPIOD, GPIO_Pin_14);\n  106  \n  107:         /* Insert delay */\n  108:         rt_thread_delay(RT_TICK_PER_SECOND/2);\n  109          f_var3 += f_var4;\n  110          f_var4 = f_var4 * f_var4;\n  ...\n  113          GPIO_SetBits(GPIOD, GPIO_Pin_15);\n  114  \n  115:         /* Insert delay */\n  116:         rt_thread_delay(RT_TICK_PER_SECOND*2);\n  117          f_var3 += f_var4;\n  118          f_var4 = f_var4 * f_var4;\n  ...\n  120          GPIO_ResetBits(GPIOD, GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);\n  121  \n  122:         /* Insert delay */\n  123:         rt_thread_delay(RT_TICK_PER_SECOND);\n  124          f_var3 += f_var4;\n  125          f_var4 = f_var4 * f_var4;\n  ...\n  141          sprintf(str_buffer, \"%f\", f_var_me);\n  142          rt_kprintf(\"thread1 %s\\r\\n\", str_buffer);\n  143:         rt_thread_delay(RT_TICK_PER_SECOND);\n  144      }\n  145  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_f32.c:\n   49   *   \n   50   * \\par Algorithm:   \n   51:  * The sparse filter instant structure contains an array of tap indices <code>pTapDelay</code> which specifies the locations of the non-zero coefficients.  \n   52   * This is in addition to the coefficient array <code>b</code>.  \n   53   * The implementation essentially skips the multiplications by zero and leads to an efficient realization.  \n   54   * <pre>  \n   55:  *     y[n] = b[0] * x[n-pTapDelay[0]] + b[1] * x[n-pTapDelay[1]] + b[2] * x[n-pTapDelay[2]] + ...+ b[numTaps-1] * x[n-pTapDelay[numTaps-1]]   \n   56   * </pre>   \n   57   * \\par   \n   ..\n   59   * \\par   \n   60   * <code>pCoeffs</code> points to a coefficient array of size <code>numTaps</code>;   \n   61:  * <code>pTapDelay</code> points to an array of nonzero indices and is also of size <code>numTaps</code>;  \n   62:  * <code>pState</code> points to a state array of size <code>maxDelay + blockSize</code>, where  \n   63:  * <code>maxDelay</code> is the largest offset value that is ever used in the <code>pTapDelay</code> array.  \n   64   * Some of the processing functions also require temporary working buffers.  \n   65   *  \n   ..\n   83   * The code below statically initializes each of the 4 different data type filter instance structures   \n   84   * <pre>   \n   85:  *arm_fir_sparse_instance_f32 S = {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};   \n   86:  *arm_fir_sparse_instance_q31 S = {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};   \n   87:  *arm_fir_sparse_instance_q15 S = {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};   \n   88:  *arm_fir_sparse_instance_q7 S =  {numTaps, 0, pState, pCoeffs, maxDelay, pTapDelay};   \n   89   * </pre>   \n   90   * \\par   \n   ..\n  125    float32_t *pb = pScratchIn;                    /* Temporary pointers for scratch buffer */\n  126    float32_t *pOut;                               /* Destination pointer */\n  127:   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */\n  128:   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */\n  129    uint16_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter  */\n  130    int32_t readIndex;                             /* Read index of the state buffer */\n  ...\n  136    /* BlockSize of Input samples are copied into the state buffer */\n  137    /* StateIndex points to the starting position to write in the state buffer */\n  138:   arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,\n  139                          (int32_t *) pSrc, 1, blockSize);\n  140  \n  141  \n  142    /* Read Index, from where the state buffer should be read, is calculated. */\n  143:   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  144  \n  145    /* Wraparound of readIndex */\n  146    if(readIndex < 0)\n  147    {\n  148:     readIndex += (int32_t) delaySize;\n  149    }\n  150  \n  ...\n  153  \n  154    /* blockSize samples are read from the state buffer */\n  155:   arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,\n  156                         (int32_t *) pb, (int32_t *) pb, blockSize, 1,\n  157                         blockSize);\n  ...\n  202  \n  203    /* Read Index, from where the state buffer should be read, is calculated. */\n  204:   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  205  \n  206    /* Wraparound of readIndex */\n  207    if(readIndex < 0)\n  208    {\n  209:     readIndex += (int32_t) delaySize;\n  210    }\n  211  \n  ...\n  220  \n  221      /* blockSize samples are read from the state buffer */\n  222:     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,\n  223                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,\n  224                           blockSize);\n  ...\n  265      /* Read Index, from where the state buffer should be read, is calculated. */\n  266      readIndex = ((int32_t) S->stateIndex -\n  267:                  (int32_t) blockSize) - *pTapDelay++;\n  268  \n  269      /* Wraparound of readIndex */\n  270      if(readIndex < 0)\n  271      {\n  272:       readIndex += (int32_t) delaySize;\n  273      }\n  274  \n  ...\n  297  \n  298    /* Read Index, from where the state buffer should be read, is calculated. */\n  299:   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  300  \n  301    /* Wraparound of readIndex */\n  302    if(readIndex < 0)\n  303    {\n  304:     readIndex += (int32_t) delaySize;\n  305    }\n  306  \n  ...\n  315  \n  316      /* blockSize samples are read from the state buffer */\n  317:     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,\n  318                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,\n  319                           blockSize);\n  ...\n  342      /* Read Index, from where the state buffer should be read, is calculated. */\n  343      readIndex =\n  344:       ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  345  \n  346      /* Wraparound of readIndex */\n  347      if(readIndex < 0)\n  348      {\n  349:       readIndex += (int32_t) delaySize;\n  350      }\n  351  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_init_f32.c:\n   48   * @param[in]     *pCoeffs   points to the array of filter coefficients.  \n   49   * @param[in]     *pState    points to the state buffer.  \n   50:  * @param[in]     *pTapDelay points to the array of offset times.  \n   51:  * @param[in]     maxDelay   maximum offset time supported.  \n   52   * @param[in]     blockSize  number of samples that will be processed per block.  \n   53   * @return none  \n   ..\n   57   * <code>pCoeffs</code> holds the filter coefficients and has length <code>numTaps</code>.   \n   58   * <code>pState</code> holds the filter's state variables and must be of length   \n   59:  * <code>maxDelay + blockSize</code>, where <code>maxDelay</code>   \n   60:  * is the maximum number of delay line values.   \n   61   * <code>blockSize</code> is the   \n   62   * number of samples processed by the <code>arm_fir_sparse_f32()</code> function.   \n   ..\n   68    float32_t * pCoeffs,\n   69    float32_t * pState,\n   70:   int32_t * pTapDelay,\n   71:   uint16_t maxDelay,\n   72    uint32_t blockSize)\n   73  {\n   ..\n   78    S->pCoeffs = pCoeffs;\n   79  \n   80:   /* Assign TapDelay pointer */\n   81:   S->pTapDelay = pTapDelay;\n   82  \n   83:   /* Assign MaxDelay */\n   84:   S->maxDelay = maxDelay;\n   85  \n   86    /* reset the stateIndex to 0 */\n   87    S->stateIndex = 0u;\n   88  \n   89:   /* Clear state buffer and size is always maxDelay + blockSize */\n   90:   memset(pState, 0, (maxDelay + blockSize) * sizeof(float32_t));\n   91  \n   92    /* Assign state pointer */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_init_q15.c:\n   48   * @param[in]     *pCoeffs   points to the array of filter coefficients.  \n   49   * @param[in]     *pState    points to the state buffer.  \n   50:  * @param[in]     *pTapDelay points to the array of offset times.  \n   51:  * @param[in]     maxDelay   maximum offset time supported.  \n   52   * @param[in]     blockSize  number of samples that will be processed per block.  \n   53   * @return none  \n   ..\n   57   * <code>pCoeffs</code> holds the filter coefficients and has length <code>numTaps</code>.   \n   58   * <code>pState</code> holds the filter's state variables and must be of length   \n   59:  * <code>maxDelay + blockSize</code>, where <code>maxDelay</code>   \n   60:  * is the maximum number of delay line values.   \n   61   * <code>blockSize</code> is the   \n   62   * number of words processed by <code>arm_fir_sparse_q15()</code> function.   \n   ..\n   68    q15_t * pCoeffs,\n   69    q15_t * pState,\n   70:   int32_t * pTapDelay,\n   71:   uint16_t maxDelay,\n   72    uint32_t blockSize)\n   73  {\n   ..\n   78    S->pCoeffs = pCoeffs;\n   79  \n   80:   /* Assign TapDelay pointer */\n   81:   S->pTapDelay = pTapDelay;\n   82  \n   83:   /* Assign MaxDelay */\n   84:   S->maxDelay = maxDelay;\n   85  \n   86    /* reset the stateIndex to 0 */\n   87    S->stateIndex = 0u;\n   88  \n   89:   /* Clear state buffer and size is always maxDelay + blockSize */\n   90:   memset(pState, 0, (maxDelay + blockSize) * sizeof(q15_t));\n   91  \n   92    /* Assign state pointer */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_init_q31.c:\n   48   * @param[in]     *pCoeffs   points to the array of filter coefficients.  \n   49   * @param[in]     *pState    points to the state buffer.  \n   50:  * @param[in]     *pTapDelay points to the array of offset times.  \n   51:  * @param[in]     maxDelay   maximum offset time supported.  \n   52   * @param[in]     blockSize  number of samples that will be processed per block.  \n   53   * @return none  \n   ..\n   57   * <code>pCoeffs</code> holds the filter coefficients and has length <code>numTaps</code>.   \n   58   * <code>pState</code> holds the filter's state variables and must be of length   \n   59:  * <code>maxDelay + blockSize</code>, where <code>maxDelay</code>   \n   60:  * is the maximum number of delay line values.   \n   61   * <code>blockSize</code> is the number of words processed by <code>arm_fir_sparse_q31()</code> function.   \n   62   */\n   ..\n   67    q31_t * pCoeffs,\n   68    q31_t * pState,\n   69:   int32_t * pTapDelay,\n   70:   uint16_t maxDelay,\n   71    uint32_t blockSize)\n   72  {\n   ..\n   77    S->pCoeffs = pCoeffs;\n   78  \n   79:   /* Assign TapDelay pointer */\n   80:   S->pTapDelay = pTapDelay;\n   81  \n   82:   /* Assign MaxDelay */\n   83:   S->maxDelay = maxDelay;\n   84  \n   85    /* reset the stateIndex to 0 */\n   86    S->stateIndex = 0u;\n   87  \n   88:   /* Clear state buffer and size is always maxDelay + blockSize */\n   89:   memset(pState, 0, (maxDelay + blockSize) * sizeof(q31_t));\n   90  \n   91    /* Assign state pointer */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_init_q7.c:\n   48   * @param[in]     *pCoeffs   points to the array of filter coefficients.  \n   49   * @param[in]     *pState    points to the state buffer.  \n   50:  * @param[in]     *pTapDelay points to the array of offset times.  \n   51:  * @param[in]     maxDelay   maximum offset time supported.  \n   52   * @param[in]     blockSize  number of samples that will be processed per block.  \n   53   * @return none  \n   ..\n   57   * <code>pCoeffs</code> holds the filter coefficients and has length <code>numTaps</code>.   \n   58   * <code>pState</code> holds the filter's state variables and must be of length   \n   59:  * <code>maxDelay + blockSize</code>, where <code>maxDelay</code>   \n   60:  * is the maximum number of delay line values.   \n   61   * <code>blockSize</code> is the   \n   62   * number of samples processed by the <code>arm_fir_sparse_q7()</code> function.   \n   ..\n   68    q7_t * pCoeffs,\n   69    q7_t * pState,\n   70:   int32_t * pTapDelay,\n   71:   uint16_t maxDelay,\n   72    uint32_t blockSize)\n   73  {\n   ..\n   78    S->pCoeffs = pCoeffs;\n   79  \n   80:   /* Assign TapDelay pointer */\n   81:   S->pTapDelay = pTapDelay;\n   82  \n   83:   /* Assign MaxDelay */\n   84:   S->maxDelay = maxDelay;\n   85  \n   86    /* reset the stateIndex to 0 */\n   87    S->stateIndex = 0u;\n   88  \n   89:   /* Clear state buffer and size is always maxDelay + blockSize */\n   90:   memset(pState, 0, (maxDelay + blockSize) * sizeof(q7_t));\n   91  \n   92    /* Assign state pointer */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_q15.c:\n   74    q15_t *pb = pScratchIn;                        /* Temporary pointers for scratch buffer */\n   75    q15_t *py = pState;                            /* Temporary pointers for state buffer */\n   76:   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */\n   77:   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */\n   78    uint16_t numTaps = S->numTaps;                 /* Filter order */\n   79    int32_t readIndex;                             /* Read index of the state buffer */\n   ..\n   92    /* BlockSize of Input samples are copied into the state buffer */\n   93    /* StateIndex points to the starting position to write in the state buffer */\n   94:   arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);\n   95  \n   96    /* Loop over the number of taps. */\n   ..\n   98  \n   99    /* Read Index, from where the state buffer should be read, is calculated. */\n  100:   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;\n  101  \n  102    /* Wraparound of readIndex */\n  103    if(readIndex < 0)\n  104    {\n  105:     readIndex += (int32_t) delaySize;\n  106    }\n  107  \n  ...\n  110  \n  111    /* blockSize samples are read from the state buffer */\n  112:   arm_circularRead_q15(py, delaySize, &readIndex, 1,\n  113                         pb, pb, blockSize, 1, blockSize);\n  114  \n  ...\n  153  \n  154    /* Read Index, from where the state buffer should be read, is calculated. */\n  155:   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;\n  156  \n  157    /* Wraparound of readIndex */\n  158    if(readIndex < 0)\n  159    {\n  160:     readIndex += (int32_t) delaySize;\n  161    }\n  162  \n  ...\n  170  \n  171      /* blockSize samples are read from the state buffer */\n  172:     arm_circularRead_q15(py, delaySize, &readIndex, 1,\n  173                           pb, pb, blockSize, 1, blockSize);\n  174  \n  ...\n  213  \n  214      /* Read Index, from where the state buffer should be read, is calculated. */\n  215:     readIndex = (S->stateIndex - blockSize) - *pTapDelay++;\n  216  \n  217      /* Wraparound of readIndex */\n  218      if(readIndex < 0)\n  219      {\n  220:       readIndex += (int32_t) delaySize;\n  221      }\n  222  \n  ...\n  287    /* BlockSize of Input samples are copied into the state buffer */\n  288    /* StateIndex points to the starting position to write in the state buffer */\n  289:   arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);\n  290  \n  291    /* Loop over the number of taps. */\n  ...\n  293  \n  294    /* Read Index, from where the state buffer should be read, is calculated. */\n  295:   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;\n  296  \n  297    /* Wraparound of readIndex */\n  298    if(readIndex < 0)\n  299    {\n  300:     readIndex += (int32_t) delaySize;\n  301    }\n  302  \n  ...\n  305  \n  306    /* blockSize samples are read from the state buffer */\n  307:   arm_circularRead_q15(py, delaySize, &readIndex, 1,\n  308                         pb, pb, blockSize, 1, blockSize);\n  309  \n  ...\n  330  \n  331    /* Read Index, from where the state buffer should be read, is calculated. */\n  332:   readIndex = (S->stateIndex - blockSize) - *pTapDelay++;\n  333  \n  334    /* Wraparound of readIndex */\n  335    if(readIndex < 0)\n  336    {\n  337:     readIndex += (int32_t) delaySize;\n  338    }\n  339  \n  ...\n  347  \n  348      /* blockSize samples are read from the state buffer */\n  349:     arm_circularRead_q15(py, delaySize, &readIndex, 1,\n  350                           pb, pb, blockSize, 1, blockSize);\n  351  \n  ...\n  372  \n  373      /* Read Index, from where the state buffer should be read, is calculated. */\n  374:     readIndex = (S->stateIndex - blockSize) - *pTapDelay++;\n  375  \n  376      /* Wraparound of readIndex */\n  377      if(readIndex < 0)\n  378      {\n  379:       readIndex += (int32_t) delaySize;\n  380      }\n  381  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_q31.c:\n   71    q31_t *pOut;                                   /* Destination pointer */\n   72    q63_t out;                                     /* Temporary output variable */\n   73:   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */\n   74:   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */\n   75    uint16_t numTaps = S->numTaps;                 /* Filter order */\n   76    int32_t readIndex;                             /* Read index of the state buffer */\n   ..\n   82    /* BlockSize of Input samples are copied into the state buffer */\n   83    /* StateIndex points to the starting position to write in the state buffer */\n   84:   arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,\n   85                          (int32_t *) pSrc, 1, blockSize);\n   86  \n   87    /* Read Index, from where the state buffer should be read, is calculated. */\n   88:   readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;\n   89  \n   90    /* Wraparound of readIndex */\n   91    if(readIndex < 0)\n   92    {\n   93:     readIndex += (int32_t) delaySize;\n   94    }\n   95  \n   ..\n   98  \n   99    /* blockSize samples are read from the state buffer */\n  100:   arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,\n  101                         (int32_t *) pb, (int32_t *) pb, blockSize, 1,\n  102                         blockSize);\n  ...\n  147  \n  148    /* Read Index, from where the state buffer should be read, is calculated. */\n  149:   readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;\n  150  \n  151    /* Wraparound of readIndex */\n  152    if(readIndex < 0)\n  153    {\n  154:     readIndex += (int32_t) delaySize;\n  155    }\n  156  \n  ...\n  164  \n  165      /* blockSize samples are read from the state buffer */\n  166:     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,\n  167                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,\n  168                           blockSize);\n  ...\n  220  \n  221      /* Read Index, from where the state buffer should be read, is calculated. */\n  222:     readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;\n  223  \n  224      /* Wraparound of readIndex */\n  225      if(readIndex < 0)\n  226      {\n  227:       readIndex += (int32_t) delaySize;\n  228      }\n  229  \n  ...\n  287  \n  288    /* Read Index, from where the state buffer should be read, is calculated. */\n  289:   readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;\n  290  \n  291    /* Wraparound of readIndex */\n  292    if(readIndex < 0)\n  293    {\n  294:     readIndex += (int32_t) delaySize;\n  295    }\n  296  \n  ...\n  304  \n  305      /* blockSize samples are read from the state buffer */\n  306:     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,\n  307                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,\n  308                           blockSize);\n  ...\n  332  \n  333      /* Read Index, from where the state buffer should be read, is calculated. */\n  334:     readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;\n  335  \n  336      /* Wraparound of readIndex */\n  337      if(readIndex < 0)\n  338      {\n  339:       readIndex += (int32_t) delaySize;\n  340      }\n  341  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\DSP_Lib\\Source\\FilteringFunctions\\arm_fir_sparse_q7.c:\n   78    q7_t *pb = pScratchIn;                         /* Temporary pointers for scratch buffer */\n   79    q7_t *pOut = pDst;                             /* Destination pointer */\n   80:   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */\n   81:   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */\n   82    uint16_t numTaps = S->numTaps;                 /* Filter order */\n   83    int32_t readIndex;                             /* Read index of the state buffer */\n   ..\n   96    /* BlockSize of Input samples are copied into the state buffer */\n   97    /* StateIndex points to the starting position to write in the state buffer */\n   98:   arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,\n   99                         blockSize);\n  100  \n  ...\n  103  \n  104    /* Read Index, from where the state buffer should be read, is calculated. */\n  105:   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  106  \n  107    /* Wraparound of readIndex */\n  108    if(readIndex < 0)\n  109    {\n  110:     readIndex += (int32_t) delaySize;\n  111    }\n  112  \n  ...\n  115  \n  116    /* blockSize samples are read from the state buffer */\n  117:   arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,\n  118                        (int32_t) blockSize, 1, blockSize);\n  119  \n  ...\n  158  \n  159    /* Read Index, from where the state buffer should be read, is calculated. */\n  160:   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  161  \n  162    /* Wraparound of readIndex */\n  163    if(readIndex < 0)\n  164    {\n  165:     readIndex += (int32_t) delaySize;\n  166    }\n  167  \n  ...\n  175  \n  176      /* blockSize samples are read from the state buffer */\n  177:     arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,\n  178                          (int32_t) blockSize, 1, blockSize);\n  179  \n  ...\n  224      /* Read Index, from where the state buffer should be read, is calculated. */\n  225      readIndex = ((int32_t) S->stateIndex -\n  226:                  (int32_t) blockSize) - *pTapDelay++;\n  227  \n  228      /* Wraparound of readIndex */\n  229      if(readIndex < 0)\n  230      {\n  231:       readIndex += (int32_t) delaySize;\n  232      }\n  233  \n  ...\n  272    /* BlockSize of Input samples are copied into the state buffer */\n  273    /* StateIndex points to the starting position to write in the state buffer */\n  274:   arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,\n  275                         blockSize);\n  276  \n  ...\n  279  \n  280    /* Read Index, from where the state buffer should be read, is calculated. */\n  281:   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  282  \n  283    /* Wraparound of readIndex */\n  284    if(readIndex < 0)\n  285    {\n  286:     readIndex += (int32_t) delaySize;\n  287    }\n  288  \n  ...\n  291  \n  292    /* blockSize samples are read from the state buffer */\n  293:   arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,\n  294                        (int32_t) blockSize, 1, blockSize);\n  295  \n  ...\n  317  \n  318    /* Read Index, from where the state buffer should be read, is calculated. */\n  319:   readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  320  \n  321    /* Wraparound of readIndex */\n  322    if(readIndex < 0)\n  323    {\n  324:     readIndex += (int32_t) delaySize;\n  325    }\n  326  \n  ...\n  334  \n  335      /* blockSize samples are read from the state buffer */\n  336:     arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,\n  337                          (int32_t) blockSize, 1, blockSize);\n  338  \n  ...\n  362      /* Read Index, from where the state buffer should be read, is calculated. */\n  363      readIndex =\n  364:       ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;\n  365  \n  366      /* Wraparound of readIndex */\n  367      if(readIndex < 0)\n  368      {\n  369:       readIndex += (int32_t) delaySize;\n  370      }\n  371  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\arm_math.h:\n 4321      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4322      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4323:     float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4324      float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/\n 4325:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4326:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4327    } arm_fir_sparse_instance_f32;\n 4328  \n ....\n 4335      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4336      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4337:     q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4338      q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/\n 4339:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4340:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4341    } arm_fir_sparse_instance_q31;\n 4342  \n ....\n 4349      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4350      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4351:     q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4352      q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/\n 4353:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4354:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4355    } arm_fir_sparse_instance_q15;\n 4356  \n ....\n 4363      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4364      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4365:     q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4366      q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/\n 4367:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4368:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4369    } arm_fir_sparse_instance_q7;\n 4370  \n ....\n 4392     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 4393     * @param[in]     *pState    points to the state buffer.\n 4394:    * @param[in]     *pTapDelay points to the array of offset times.\n 4395:    * @param[in]     maxDelay   maximum offset time supported.\n 4396     * @param[in]     blockSize  number of samples that will be processed per block.\n 4397     * @return none\n ....\n 4403  			       float32_t * pCoeffs,\n 4404  			       float32_t * pState,\n 4405: 			       int32_t * pTapDelay,\n 4406: 			       uint16_t maxDelay,\n 4407  			       uint32_t blockSize);\n 4408  \n ....\n 4430     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 4431     * @param[in]     *pState    points to the state buffer.\n 4432:    * @param[in]     *pTapDelay points to the array of offset times.\n 4433:    * @param[in]     maxDelay   maximum offset time supported.\n 4434     * @param[in]     blockSize  number of samples that will be processed per block.\n 4435     * @return none\n ....\n 4441  			       q31_t * pCoeffs,\n 4442  			       q31_t * pState,\n 4443: 			       int32_t * pTapDelay,\n 4444: 			       uint16_t maxDelay,\n 4445  			       uint32_t blockSize);\n 4446  \n ....\n 4471     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 4472     * @param[in]     *pState    points to the state buffer.\n 4473:    * @param[in]     *pTapDelay points to the array of offset times.\n 4474:    * @param[in]     maxDelay   maximum offset time supported.\n 4475     * @param[in]     blockSize  number of samples that will be processed per block.\n 4476     * @return none\n ....\n 4482  			       q15_t * pCoeffs,\n 4483  			       q15_t * pState,\n 4484: 			       int32_t * pTapDelay,\n 4485: 			       uint16_t maxDelay,\n 4486  			       uint32_t blockSize);\n 4487  \n ....\n 4511     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 4512     * @param[in]     *pState    points to the state buffer.\n 4513:    * @param[in]     *pTapDelay points to the array of offset times.\n 4514:    * @param[in]     maxDelay   maximum offset time supported.\n 4515     * @param[in]     blockSize  number of samples that will be processed per block.\n 4516     * @return none\n ....\n 4522  			      q7_t * pCoeffs,\n 4523  			      q7_t * pState,\n 4524: 			      int32_t *pTapDelay,\n 4525: 			      uint16_t maxDelay,\n 4526  			      uint32_t blockSize);\n 4527  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\CMSIS\\ST\\STM32F4xx\\Include\\stm32f4xx.h:\n 1579  #define  ADC_CCR_MULTI_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */\n 1580  #define  ADC_CCR_MULTI_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */\n 1581: #define  ADC_CCR_DELAY                       ((uint32_t)0x00000F00)        /*!<DELAY[3:0] bits (Delay between 2 sampling phases) */  \n 1582: #define  ADC_CCR_DELAY_0                     ((uint32_t)0x00000100)        /*!<Bit 0 */\n 1583: #define  ADC_CCR_DELAY_1                     ((uint32_t)0x00000200)        /*!<Bit 1 */\n 1584: #define  ADC_CCR_DELAY_2                     ((uint32_t)0x00000400)        /*!<Bit 2 */\n 1585: #define  ADC_CCR_DELAY_3                     ((uint32_t)0x00000800)        /*!<Bit 3 */\n 1586  #define  ADC_CCR_DDS                         ((uint32_t)0x00002000)        /*!<DMA disable selection (Multi-ADC mode) */\n 1587  #define  ADC_CCR_DMA                         ((uint32_t)0x0000C000)        /*!<DMA[1:0] bits (Direct Memory Access mode for multimode) */  \n ....\n 3847  #define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */\n 3848  \n 3849: #define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */\n 3850  #define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */\n 3851  #define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */\n ....\n 3853  #define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */\n 3854  \n 3855: #define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */\n 3856  #define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */\n 3857  #define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */\n ....\n 3875  #define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */\n 3876  \n 3877: #define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */\n 3878  #define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */\n 3879  #define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */\n ....\n 3881  #define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */\n 3882  \n 3883: #define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */\n 3884  #define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */\n 3885  #define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */\n ....\n 3903  #define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */\n 3904  \n 3905: #define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */\n 3906  #define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */\n 3907  #define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */\n ....\n 3909  #define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */\n 3910  \n 3911: #define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */\n 3912  #define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */\n 3913  #define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */\n ....\n 6546  #define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */\n 6547  #define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */\n 6548: #define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling\n 6549                                                         a transmission attempt during retries after a collision: 0 =< r <2^k */\n 6550    #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\inc\\stm32f4xx_adc.h:\n   88                                                 This parameter can be a value of \n   89                                                 @ref ADC_Direct_memory_access_mode_for_multi_mode */\n   90:   uint32_t ADC_TwoSamplingDelay;          /*!< Configures the Delay between 2 sampling phases.\n   91                                                 This parameter can be a value of \n   92:                                                @ref ADC_delay_between_2_sampling_phases */\n   93    \n   94  }ADC_CommonInitTypeDef;\n   ..\n  171  \n  172  \n  173: /** @defgroup ADC_delay_between_2_sampling_phases \n  174    * @{\n  175    */ \n  176: #define ADC_TwoSamplingDelay_5Cycles               ((uint32_t)0x00000000)\n  177: #define ADC_TwoSamplingDelay_6Cycles               ((uint32_t)0x00000100)\n  178: #define ADC_TwoSamplingDelay_7Cycles               ((uint32_t)0x00000200)\n  179: #define ADC_TwoSamplingDelay_8Cycles               ((uint32_t)0x00000300)\n  180: #define ADC_TwoSamplingDelay_9Cycles               ((uint32_t)0x00000400)\n  181: #define ADC_TwoSamplingDelay_10Cycles              ((uint32_t)0x00000500)\n  182: #define ADC_TwoSamplingDelay_11Cycles              ((uint32_t)0x00000600)\n  183: #define ADC_TwoSamplingDelay_12Cycles              ((uint32_t)0x00000700)\n  184: #define ADC_TwoSamplingDelay_13Cycles              ((uint32_t)0x00000800)\n  185: #define ADC_TwoSamplingDelay_14Cycles              ((uint32_t)0x00000900)\n  186: #define ADC_TwoSamplingDelay_15Cycles              ((uint32_t)0x00000A00)\n  187: #define ADC_TwoSamplingDelay_16Cycles              ((uint32_t)0x00000B00)\n  188: #define ADC_TwoSamplingDelay_17Cycles              ((uint32_t)0x00000C00)\n  189: #define ADC_TwoSamplingDelay_18Cycles              ((uint32_t)0x00000D00)\n  190: #define ADC_TwoSamplingDelay_19Cycles              ((uint32_t)0x00000E00)\n  191: #define ADC_TwoSamplingDelay_20Cycles              ((uint32_t)0x00000F00)\n  192: #define IS_ADC_SAMPLING_DELAY(DELAY) (((DELAY) == ADC_TwoSamplingDelay_5Cycles) || \\\n  193:                                       ((DELAY) == ADC_TwoSamplingDelay_6Cycles) || \\\n  194:                                       ((DELAY) == ADC_TwoSamplingDelay_7Cycles) || \\\n  195:                                       ((DELAY) == ADC_TwoSamplingDelay_8Cycles) || \\\n  196:                                       ((DELAY) == ADC_TwoSamplingDelay_9Cycles) || \\\n  197:                                       ((DELAY) == ADC_TwoSamplingDelay_10Cycles) || \\\n  198:                                       ((DELAY) == ADC_TwoSamplingDelay_11Cycles) || \\\n  199:                                       ((DELAY) == ADC_TwoSamplingDelay_12Cycles) || \\\n  200:                                       ((DELAY) == ADC_TwoSamplingDelay_13Cycles) || \\\n  201:                                       ((DELAY) == ADC_TwoSamplingDelay_14Cycles) || \\\n  202:                                       ((DELAY) == ADC_TwoSamplingDelay_15Cycles) || \\\n  203:                                       ((DELAY) == ADC_TwoSamplingDelay_16Cycles) || \\\n  204:                                       ((DELAY) == ADC_TwoSamplingDelay_17Cycles) || \\\n  205:                                       ((DELAY) == ADC_TwoSamplingDelay_18Cycles) || \\\n  206:                                       ((DELAY) == ADC_TwoSamplingDelay_19Cycles) || \\\n  207:                                       ((DELAY) == ADC_TwoSamplingDelay_20Cycles))\n  208                                       \n  209  /**\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\inc\\stm32f4xx_fsmc.h:\n  193  \n  194    uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the\n  195:                                        delay between CLE low and RE low.\n  196                                         This parameter can be a value between 0 and 0xFF. */\n  197  \n  198    uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the\n  199:                                        delay between ALE low and RE low.\n  200                                         This parameter can be a number between 0x0 and 0xFF */ \n  201  \n  ...\n  215  \n  216    uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the\n  217:                                      delay between CLE low and RE low.\n  218                                       This parameter can be a value between 0 and 0xFF. */\n  219  \n  220    uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the\n  221:                                      delay between ALE low and RE low.\n  222                                       This parameter can be a number between 0x0 and 0xFF */ \n  223  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\inc\\stm32f4xx_tim.h:\n  147                                        This parameter can be a value of @ref TIM_Lock_level */ \n  148  \n  149:   uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the\n  150                                        switching-on of the outputs.\n  151                                        This parameter can be a number between 0x00 and 0xFF  */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c:\n  191     - Multi ADC mode selection\n  192     - Direct memory access mode selection for multi ADC mode  \n  193:    - Delay between 2 sampling phases (used in dual or triple interleaved modes)\n  194     - Enable or disable the ADC peripheral\n  195     \n  ...\n  339    assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));\n  340    assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));\n  341:   assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));\n  342    /*---------------------------- ADC CCR Configuration -----------------*/\n  343    /* Get the ADC CCR value */\n  344    tmpreg1 = ADC->CCR;\n  345    \n  346:   /* Clear MULTI, DELAY, DMA and ADCPRE bits */\n  347    tmpreg1 &= CR_CLEAR_MASK;\n  348    \n  349:   /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,\n  350       and DMA access mode for multimode */\n  351    /* Set MULTI bits according to ADC_Mode value */\n  352    /* Set ADCPRE bits according to ADC_Prescaler value */\n  353    /* Set DMA bits according to ADC_DMAAccessMode value */\n  354:   /* Set DELAY bits according to ADC_TwoSamplingDelay value */    \n  355    tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | \n  356                          ADC_CommonInitStruct->ADC_Prescaler | \n  357                          ADC_CommonInitStruct->ADC_DMAAccessMode | \n  358:                         ADC_CommonInitStruct->ADC_TwoSamplingDelay);\n  359                          \n  360    /* Write to ADC CCR */\n  ...\n  379    ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;\n  380  \n  381:   /* Initialize the ADC_TwoSamplingDelay member */\n  382:   ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;\n  383  }\n  384  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_pwr.c:\n  346     function, the Flash memory also enters power down mode when the device enters \n  347     Stop mode. When the Flash memory is in power down mode, an additional startup \n  348:    delay is incurred when waking up from Stop mode.\n  349  \n  350  @endverbatim\n  ...\n  484    *         the HSI RC oscillator is selected as system clock.\n  485    * @note   When the voltage regulator operates in low power mode, an additional \n  486:   *         startup delay is incurred when waking up from Stop mode. \n  487    *         By keeping the internal regulator ON during Stop mode, the consumption \n  488    *         is higher although the startup time is reduced.           \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c:\n  673    *         (if the Clock Security System CSS is enabled).\n  674    * @note   A switch from one clock source to another occurs only if the target\n  675:   *         clock source is ready (clock stable after startup delay or PLL locked). \n  676    *         If a clock source which is not yet ready is selected, the switch will\n  677    *         occur when the clock source will be ready. \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_usart.c:\n  994        not be rejected.\n  995  @note The receiver set up time should be managed by software. The IrDA physical layer\n  996:       specification specifies a minimum of 10 ms delay between transmission and \n  997        reception (IrDA is a half duplex protocol).\n  998  @note In IrDA mode, the following bits must be kept cleared:\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\CMSIS\\Include\\arm_math.h:\n 4812      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4813      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4814:     float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4815      float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/\n 4816:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4817:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4818    } arm_fir_sparse_instance_f32;\n 4819  \n ....\n 4826      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4827      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4828:     q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4829      q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/\n 4830:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4831:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4832    } arm_fir_sparse_instance_q31;\n 4833  \n ....\n 4840      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4841      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4842:     q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4843      q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/\n 4844:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4845:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4846    } arm_fir_sparse_instance_q15;\n 4847  \n ....\n 4854      uint16_t numTaps;             /**< number of coefficients in the filter. */\n 4855      uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */\n 4856:     q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */\n 4857      q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/\n 4858:     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */\n 4859:     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */\n 4860    } arm_fir_sparse_instance_q7;\n 4861  \n ....\n 4883     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 4884     * @param[in]     *pState    points to the state buffer.\n 4885:    * @param[in]     *pTapDelay points to the array of offset times.\n 4886:    * @param[in]     maxDelay   maximum offset time supported.\n 4887     * @param[in]     blockSize  number of samples that will be processed per block.\n 4888     * @return none\n ....\n 4894    float32_t * pCoeffs,\n 4895    float32_t * pState,\n 4896:   int32_t * pTapDelay,\n 4897:   uint16_t maxDelay,\n 4898    uint32_t blockSize);\n 4899  \n ....\n 4921     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 4922     * @param[in]     *pState    points to the state buffer.\n 4923:    * @param[in]     *pTapDelay points to the array of offset times.\n 4924:    * @param[in]     maxDelay   maximum offset time supported.\n 4925     * @param[in]     blockSize  number of samples that will be processed per block.\n 4926     * @return none\n ....\n 4932    q31_t * pCoeffs,\n 4933    q31_t * pState,\n 4934:   int32_t * pTapDelay,\n 4935:   uint16_t maxDelay,\n 4936    uint32_t blockSize);\n 4937  \n ....\n 4962     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 4963     * @param[in]     *pState    points to the state buffer.\n 4964:    * @param[in]     *pTapDelay points to the array of offset times.\n 4965:    * @param[in]     maxDelay   maximum offset time supported.\n 4966     * @param[in]     blockSize  number of samples that will be processed per block.\n 4967     * @return none\n ....\n 4973    q15_t * pCoeffs,\n 4974    q15_t * pState,\n 4975:   int32_t * pTapDelay,\n 4976:   uint16_t maxDelay,\n 4977    uint32_t blockSize);\n 4978  \n ....\n 5002     * @param[in]     *pCoeffs   points to the array of filter coefficients.\n 5003     * @param[in]     *pState    points to the state buffer.\n 5004:    * @param[in]     *pTapDelay points to the array of offset times.\n 5005:    * @param[in]     maxDelay   maximum offset time supported.\n 5006     * @param[in]     blockSize  number of samples that will be processed per block.\n 5007     * @return none\n ....\n 5013    q7_t * pCoeffs,\n 5014    q7_t * pState,\n 5015:   int32_t * pTapDelay,\n 5016:   uint16_t maxDelay,\n 5017    uint32_t blockSize);\n 5018  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\CMSIS\\RTOS\\cmsis_os.h:\n  369  //  ==== Generic Wait Functions ====\n  370  \n  371: /// Wait for Timeout (Time Delay)\n  372: /// \\param[in]     millisec      time delay value \n  373  /// \\return status code that indicates the execution status of the function.\n  374: osStatus osDelay (uint32_t millisec);\n  375  \n  376  #if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0))     // Generic Wait available\n  ...\n  417  /// Start or restart a timer.\n  418  /// \\param[in]     timer_id      timer ID obtained by \\ref osTimerCreate.\n  419: /// \\param[in]     millisec      time delay value of the timer.\n  420  /// \\return status code that indicates the execution status of the function.\n  421  /// \\note MUST REMAIN UNCHANGED: \\b osTimerStart shall be consistent in every CMSIS-RTOS.\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\CMSIS\\RTOS\\cmsis_rtthread.c:\n   98  // Generic Wait API\n   99  \n  100: /// Wait for Timeout (Time Delay)\n  101: osStatus osDelay(uint32_t millisec)\n  102  {\n  103  	rt_err_t result;\n  ...\n  105  \n  106  	ticks = rt_tick_from_millisecond(millisec);\n  107: 	result = rt_thread_delay(ticks);\n  108  \n  109  	if (result == RT_EOK)\n  ...\n  120  \n  121  	ticks = rt_tick_from_millisecond(millisec);\n  122: 	result = rt_thread_delay(ticks);\n  123  /*\n  124  	if (result == RT_EOK)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\dfs\\filesystems\\jffs2\\include\\port\\fcntl.h:\n   20  #define O_APPEND     (1<<7)    /* Set append mode */\n   21  #define O_DSYNC      (1<<8)    /* Synchronized I/O data integrity writes */\n   22: #define O_NONBLOCK   (1<<9)    /* No delay */\n   23  #define O_RSYNC      (1<<10)   /* Synchronized read I/O */\n   24  #define O_SYNC       (1<<11)   /* Synchronized I/O file integrity writes */\n   ..\n   45  #define JFFS2_O_APPEND     (1<<7)    /* Set append mode */\n   46  #define JFFS2_O_DSYNC      (1<<8)    /* Synchronized I/O data integrity writes */\n   47: #define JFFS2_O_NONBLOCK   (1<<9)    /* No delay */\n   48  #define JFFS2_O_RSYNC      (1<<10)   /* Synchronized read I/O */\n   49  #define JFFS2_O_SYNC       (1<<11)   /* Synchronized I/O file integrity writes */\n   ..\n   72  #define JFFS2_O_APPEND     (DFS_O_APPEND)  /* Set append mode */\n   73  #define JFFS2_O_DSYNC      (DFS_O_DSYNC)   /* Synchronized I/O data integrity writes */\n   74: #define JFFS2_O_NONBLOCK   (DFS_O_NONBLOCK)/* No delay */\n   75  #define JFFS2_O_RSYNC      (DFS_O_RSYNC)   /* Synchronized read I/O */\n   76  #define JFFS2_O_SYNC       (DFS_O_SYNC)    /* Synchronized I/O file integrity writes */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\dfs\\filesystems\\jffs2\\include\\port\\sys\\stat.h:\n  131  \n  132  /* Minimal number of timer expiration overruns.  */\n  133: #define _POSIX_DELAYTIMER_MAX	32\n  134  \n  135  /* Maximum link count of a file.  */\n  ...\n  347  \n  348  //fcntl.h\n  349: #define O_NONBLOCK   (1<<9)    /* No delay */\n  350  \n  351  #endif /* CYGONCE_ISO_SYS_TYPES_H multiple inclusion protection */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\dfs\\filesystems\\jffs2\\src\\gc.c:\n  326  		   Q: What are the chances that the inode is back in INO_STATE_READING\n  327  		   again by the time we next enter this function? And that this happens\n  328: 		   enough times to cause a real delay?\n  329  \n  330  		   A: Small enough that I don't care :)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\i2c\\i2c-bit-ops.c:\n   26  #define GET_SCL(ops)        ops->get_scl(ops->data)\n   27  \n   28: rt_inline void i2c_delay(struct rt_i2c_bit_ops *ops)\n   29  {\n   30:     ops->udelay((ops->delay_us + 1) >> 1);\n   31  }\n   32  \n   33: rt_inline void i2c_delay2(struct rt_i2c_bit_ops *ops)\n   34  {\n   35:     ops->udelay(ops->delay_us);\n   36  }\n   37  \n   ..\n   57          if ((rt_tick_get() - start) > ops->timeout)\n   58              return -RT_ETIMEOUT;\n   59:         rt_thread_delay((ops->timeout + 1) >> 1);\n   60      }\n   61  #ifdef RT_I2C_BIT_DEBUG\n   ..\n   68  \n   69  done:\n   70:     i2c_delay(ops);\n   71  \n   72      return RT_EOK;\n   ..\n   86  #endif\n   87      SDA_L(ops);\n   88:     i2c_delay(ops);\n   89      SCL_L(ops);\n   90  }\n   ..\n   94      SDA_H(ops);\n   95      SCL_H(ops);\n   96:     i2c_delay(ops);\n   97      SDA_L(ops);\n   98:     i2c_delay(ops);\n   99      SCL_L(ops);\n  100  }\n  ...\n  103  {\n  104      SDA_L(ops);\n  105:     i2c_delay(ops);\n  106      SCL_H(ops);\n  107:     i2c_delay(ops);\n  108      SDA_H(ops);\n  109:     i2c_delay2(ops);\n  110  }\n  111  \n  ...\n  115  \n  116      SDA_H(ops);\n  117:     i2c_delay(ops);\n  118  \n  119      if (SCL_H(ops) < 0)\n  ...\n  144          bit = (data >> i) & 1;\n  145          SET_SDA(ops, bit);\n  146:         i2c_delay(ops);\n  147          if (SCL_H(ops) < 0)\n  148          {\n  ...\n  155      }\n  156      SCL_L(ops);\n  157:     i2c_delay(ops);\n  158  \n  159      return i2c_waitack(ops);\n  ...\n  167  \n  168      SDA_H(ops);\n  169:     i2c_delay(ops);\n  170      for (i = 0; i < 8; i++)\n  171      {\n  ...\n  183              data |= 1;\n  184          SCL_L(ops);\n  185:         i2c_delay2(ops);\n  186      }\n  187  \n  ...\n  231      if (ack)\n  232          SET_SDA(ops, 0);\n  233:     i2c_delay(ops);\n  234      if (SCL_H(ops) < 0)\n  235      {\n  ...\n  298          bit_dbg(\"send stop condition\\n\");\n  299          i2c_stop(ops);\n  300:         i2c_delay2(ops);\n  301          bit_dbg(\"send start condition\\n\");\n  302          i2c_start(ops);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\include\\drivers\\i2c-bit-ops.h:\n   28      rt_int32_t (*get_scl)(void *data);\n   29  \n   30:     void (*udelay)(rt_uint32_t us);\n   31  \n   32:     rt_uint32_t delay_us;  /* scl and sda line delay */\n   33      rt_uint32_t timeout;   /* in tick */\n   34  };\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\include\\drivers\\mmcsd_host.h:\n  112  };\n  113  \n  114: rt_inline void mmcsd_delay_ms(rt_uint32_t ms)\n  115  {\n  116  	if (ms < 1000 / RT_TICK_PER_SECOND) \n  117  	{\n  118: 		rt_thread_delay(1);\n  119  	} \n  120  	else \n  121  	{\n  122: 		rt_thread_delay(ms/(1000 / RT_TICK_PER_SECOND));\n  123  	}\n  124  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\rtc\\alarm.c:\n   17  \n   18  #define RT_RTC_YEARS_MAX         137\n   19: #define RT_ALARM_DELAY             2\n   20  #define RT_ALARM_STATE_INITED   0x02\n   21  #define RT_ALARM_STATE_START    0x01\n   ..\n   92              sec_alarm = mktime(&alarm->wktime);\n   93              sec_now = mktime(now);\n   94:             if (((sec_now - sec_alarm) <= RT_ALARM_DELAY) && (sec_now >= sec_alarm))\n   95              {\n   96                  /* stop alarm */\n   ..\n  103          case RT_ALARM_DAILY:\n  104          {\n  105:             if (((sec_now - sec_alarm) <= RT_ALARM_DELAY) && (sec_now >= sec_alarm))\n  106                  wakeup = RT_TRUE;\n  107          }\n  ...\n  113              sec_now += now->tm_wday * 24 * 3600;\n  114  \n  115:             if (((sec_now - sec_alarm) <= RT_ALARM_DELAY) && (sec_now >= sec_alarm))\n  116                  wakeup = RT_TRUE;\n  117          }\n  ...\n  122              if (alarm->wktime.tm_mday == now->tm_mday)\n  123              {\n  124:                 if ((sec_now - sec_alarm) <= RT_ALARM_DELAY)\n  125                      wakeup = RT_TRUE;\n  126              }\n  ...\n  132                  (alarm->wktime.tm_mon == now->tm_mon))\n  133              {\n  134:                   if ((sec_now - sec_alarm) <= RT_ALARM_DELAY)\n  135                      wakeup = RT_TRUE;           \n  136              }\n  ...\n  359             signal two seconds ahead of.\n  360          */\n  361:         setup->tm_sec = 60 - RT_ALARM_DELAY;\n  362      }\n  363      /* set initialized state */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\sdio\\mmcsd_core.c:\n   91  	if (!controller_is_spi(host)) {\n   92  		mmcsd_set_chip_select(host, MMCSD_CS_HIGH);\n   93: 		mmcsd_delay_ms(1);\n   94  	}\n   95  \n   ..\n  102  	err = mmcsd_send_cmd(host, &cmd, 0);\n  103  \n  104: 	mmcsd_delay_ms(1);\n  105  \n  106  	if (!controller_is_spi(host)) \n  107  	{\n  108  		mmcsd_set_chip_select(host, MMCSD_CS_IGNORE);\n  109: 		mmcsd_delay_ms(1);\n  110  	}\n  111  \n  ...\n  534  \n  535  	/*\n  536: 	 * This delay should be sufficient to allow the power supply\n  537  	 * to reach the minimum voltage.\n  538  	 */\n  539: 	mmcsd_delay_ms(10);\n  540  \n  541  	host->io_cfg.clock = host->freq_min;\n  ...\n  544  \n  545  	/*\n  546: 	 * This delay must be at least 74 clock sizes, or 1 ms, or the\n  547  	 * time required to reach a stable voltage.\n  548  	 */\n  549: 	mmcsd_delay_ms(10);\n  550  }\n  551  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\sdio\\sd.c:\n  421  		err = -RT_ETIMEOUT;\n  422  \n  423: 		mmcsd_delay_ms(10); //delay 10ms\n  424  	}\n  425  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\sdio\\sdio.c:\n   92  		err = -RT_ETIMEOUT;\n   93  \n   94: 		mmcsd_delay_ms(10);\n   95  	}\n   96  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\usb\\usbhost\\core\\core.c:\n  281          timeout) != 0) return -RT_EIO;\n  282  \n  283:     rt_thread_delay(50);\n  284  \n  285      uinst->address = uinst->index;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\drivers\\usb\\usbhost\\core\\hub.c:\n  216      RT_ASSERT(uhub != RT_NULL);\n  217      \n  218:     rt_thread_delay(50);\n  219  \n  220      /* reset hub port */\n  ...\n  232      if(ret != RT_EOK) return ret;\n  233  \n  234:     rt_thread_delay(50);    \n  235  \n  236      return RT_EOK;\n  ...\n  266          }\n  267          \n  268:         rt_thread_delay(1);\n  269      }        \n  270  \n  ...\n  443      {\n  444          rt_usb_hub_set_port_feature(uhub, i + 1, PORT_FEAT_POWER);\n  445:         rt_thread_delay(uhub->hub_desc.pwron_to_good\n  446              * 2 * RT_TICK_PER_SECOND / 1000 );\n  447      }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\freetype\\builds\\mac\\ftmac.c:\n 1387  \n 1388  \n 1389:     /* test for valid `library' and `aface' delayed to FT_Open_Face() */\n 1390      if ( !pathname )\n 1391        return FT_Err_Invalid_Argument;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\freetype\\src\\base\\ftinit.c:\n  181  \n  182  \n  183:     /* test for valid `library' delayed to FT_Add_Module() */\n  184  \n  185      cur = FT_DEFAULT_MODULES_GET;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\freetype\\src\\base\\ftmac.c:\n  958  \n  959  \n  960:     /* test for valid `library' and `aface' delayed to FT_Open_Face() */\n  961      if ( !pathname )\n  962        return FT_Err_Invalid_Argument;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\freetype\\src\\base\\ftobjs.c:\n 1163  \n 1164  \n 1165:     /* test for valid `library' and `aface' delayed to FT_Open_Face() */\n 1166      if ( !pathname )\n 1167        return FT_Err_Invalid_Argument;\n ....\n 1189  \n 1190  \n 1191:     /* test for valid `library' and `face' delayed to FT_Open_Face() */\n 1192      if ( !file_base )\n 1193        return FT_Err_Invalid_Argument;\n ....\n 1924  \n 1925  \n 1926:     /* test for valid `library' delayed to */\n 1927      /* FT_Stream_New()                     */\n 1928  \n ....\n 2170  \n 2171  \n 2172:     /* test for valid `face' delayed to FT_Attach_Stream() */\n 2173  \n 2174      if ( !filepathname )\n ....\n 2196  \n 2197  \n 2198:     /* test for valid `parameters' delayed to FT_Stream_New() */\n 2199  \n 2200      if ( !face )\n ....\n 3721                     FT_Glyph_Format  format )\n 3722    {\n 3723:     /* test for valid `library' delayed to FT_Lookup_Renderer() */\n 3724  \n 3725      return FT_Lookup_Renderer( library, format, 0 );\n ....\n 4076  \n 4077  \n 4078:     /* test for valid `library' delayed to FT_Get_Module() */\n 4079  \n 4080      module = FT_Get_Module( library, mod_name );\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\freetype\\src\\base\\ftoutln.c:\n  653        return FT_Err_Invalid_Argument;\n  654  \n  655:     /* other checks are delayed to FT_Outline_Render() */\n  656  \n  657      params.target = abitmap;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\freetype\\src\\cache\\ftcbasic.c:\n  322  \n  323  \n  324:     /* some argument checks are delayed to FTC_Cache_Lookup */\n  325      if ( !aglyph )\n  326      {\n  ...\n  418  \n  419  \n  420:     /* some argument checks are delayed to FTC_Cache_Lookup */\n  421      if ( !aglyph || !scaler )\n  422      {\n  ...\n  663        *anode = NULL;\n  664  \n  665:     /* other argument checks delayed to FTC_Cache_Lookup */\n  666      if ( !ansbit )\n  667        return FTC_Err_Invalid_Argument;\n  ...\n  760          *anode = NULL;\n  761  \n  762:     /* other argument checks delayed to FTC_Cache_Lookup */\n  763      if ( !ansbit || !scaler )\n  764          return FTC_Err_Invalid_Argument;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\freetype\\src\\sfnt\\ttcmap.c:\n  943            /* segment if it contains only a single character.     */\n  944            /*                                                     */\n  945:           /* We thus omit the test here, delaying it to the      */\n  946            /* routines which actually access the cmap.            */\n  947            else if ( n != num_segs - 1                       ||\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\jpeg\\cjpeg.c:\n  343  	usage();\n  344        qslotsarg = argv[argn];\n  345:       /* Must delay setting qslots until after we have processed any\n  346         * colorspace-determining switches, since jpeg_set_colorspace sets\n  347         * default quant table numbers.\n  ...\n  379  	usage();\n  380        samplearg = argv[argn];\n  381:       /* Must delay setting sample factors until after we have processed any\n  382         * colorspace-determining switches, since jpeg_set_colorspace sets\n  383         * default sampling factors.\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\jpeg\\jcapistd.c:\n   94    /* Give master control module another chance if this is first call to\n   95     * jpeg_write_scanlines.  This lets output of the frame/scan headers be\n   96:    * delayed so that application can write COM, etc, markers between\n   97     * jpeg_start_compress and jpeg_write_scanlines.\n   98     */\n   ..\n  139    /* Give master control module another chance if this is first call to\n  140     * jpeg_write_raw_data.  This lets output of the frame/scan headers be\n  141:    * delayed so that application can write COM, etc, markers between\n  142     * jpeg_start_compress and jpeg_write_raw_data.\n  143     */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\external\\jpeg\\ltmain.sh:\n  399  \n  400      case $func_quote_for_eval_unquoted_result in\n  401:       # Double-quote args containing shell metacharacters to delay\n  402        # word splitting, command substitution and and variable\n  403        # expansion for a subsequent eval.\n  ...\n  427  \n  428      case $my_arg in\n  429:       # Double-quote args containing shell metacharacters to delay\n  430        # word splitting and command substitution for a subsequent eval.\n  431        # Many Bourne shells cannot handle close brackets correctly\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\libc\\minilibc\\sys\\stat.h:\n   21  #define	_FSYNC		0x2000	/* do all writes synchronously */\n   22  #define	_FNONBLOCK	0x4000	/* non blocking I/O (POSIX style) */\n   23: #define	_FNDELAY	_FNONBLOCK	/* non blocking I/O (4.2 style) */\n   24  #define	_FNOCTTY	0x8000	/* don't assign a ctty on this open */\n   25  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\apps\\ping.c:\n   23  /** ping receive timeout - in milliseconds */\n   24  #define PING_RCV_TIMEO 1000\n   25: /** ping delay - in milliseconds */\n   26: #define PING_DELAY     100\n   27  \n   28  /** ping identifier - must fit on a u16_t */\n   ..\n  165  		if (send_time >= time) break; /* send ping times reached, stop */\n  166  \n  167: 		rt_thread_delay(PING_DELAY); /* take a delay */\n  168  	}\n  169  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\apps\\sntp.c:\n   67  #endif\n   68  \n   69: /** SNTP update delay - in milliseconds */\n   70: #ifndef SNTP_UPDATE_DELAY\n   71: #define SNTP_UPDATE_DELAY           60000\n   72  #endif\n   73  \n   ..\n  204  	{\n  205  		sntp_request();\n  206: 		sys_msleep(SNTP_UPDATE_DELAY);\n  207  	}\n  208  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\core\\ipv4\\igmp.c:\n  228    while (group != NULL) {\n  229      if (group->interface == netif) {\n  230:       igmp_delaying_member( group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n  231      }\n  232      group = group->next;\n  ...\n  394           IGMP_STATS_INC(igmp.v1_rxed);\n  395           LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\\n\"));\n  396:          igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;\n  397         }\n  398  \n  ...\n  402           /* Do not send messages on the all systems group address! */\n  403           if ((groupref->interface == inp) && (!(ip_addr_cmp(&(groupref->group_address), &allsystems)))) {\n  404:            igmp_delaying_member( groupref, igmp->igmp_maxresp);\n  405           }\n  406           groupref = groupref->next;\n  ...\n  421           if (group != NULL) {\n  422             IGMP_STATS_INC(igmp.unicast_query);\n  423:            igmp_delaying_member( group, igmp->igmp_maxresp);\n  424           }\n  425         }\n  ...\n  431  \n  432       IGMP_STATS_INC(igmp.report_rxed);\n  433:      if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n  434         /* This is on a specific group we have already looked up */\n  435         group->timer = 0; /* stopped */\n  ...\n  497            igmp_send(group, IGMP_V2_MEMB_REPORT);\n  498  \n  499:           igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n  500  \n  501            /* Need to work out where this timer comes from */\n  502:           group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  503          }\n  504          /* Increment group use */\n  ...\n  622  igmp_timeout(struct igmp_group *group)\n  623  {\n  624:   /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */\n  625:   if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n  626      LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_timeout: report membership for group with address \"));\n  627      ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));\n  ...\n  660  \n  661  /**\n  662:  * Delaying membership report for a group if necessary\n  663   *\n  664:  * @param group the igmp_group for which \"delaying\" membership report\n  665:  * @param maxresp query delay\n  666   */\n  667  void\n  668: igmp_delaying_member( struct igmp_group *group, u8_t maxresp)\n  669  {\n  670    if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||\n  671:      ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) && (maxresp > group->timer))) {\n  672      igmp_start_timer(group, (maxresp)/2);\n  673:     group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  674    }\n  675  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\core\\sys.c:\n  336  sys_msleep(u32_t ms)\n  337  {\n  338:   sys_sem_t delaysem = sys_sem_new(0);\n  339  \n  340:   sys_sem_wait_timeout(delaysem, ms);\n  341  \n  342:   sys_sem_free(delaysem);\n  343  }\n  344  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\core\\tcp.c:\n  810  /**\n  811   * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously\n  812:  * \"refused\" by upper layer (application) and sends delayed ACKs.\n  813   *\n  814   * Automatically called from tcp_tmr().\n  ...\n  831      }\n  832  \n  833:     /* send delayed ACKs */  \n  834:     if (pcb->flags & TF_ACK_DELAY) {\n  835:       LWIP_DEBUGF(TCP_DEBUG, (\"tcp_fasttmr: delayed ACK\\n\"));\n  836        tcp_ack_now(pcb);\n  837:       pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n  838      }\n  839    }\n  ...\n 1248  \n 1249  /**\n 1250:  * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.\n 1251   *\n 1252   * @param pcblist PCB list to purge.\n ....\n 1260    tcp_pcb_purge(pcb);\n 1261    \n 1262:   /* if there is an outstanding delayed ACKs, send it */\n 1263    if (pcb->state != TIME_WAIT &&\n 1264       pcb->state != LISTEN &&\n 1265:      pcb->flags & TF_ACK_DELAY) {\n 1266      pcb->flags |= TF_ACK_NOW;\n 1267      tcp_output(pcb);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\core\\tcp_in.c:\n  549        LWIP_ASSERT(\"tcp_input: pcb->state != CLOSED\", pcb->state != CLOSED);\n  550        recv_flags |= TF_RESET;\n  551:       pcb->flags &= ~TF_ACK_DELAY;\n  552        return ERR_RST;\n  553      } else {\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\core\\tcp_out.c:\n  479                (\"tcp_output: sending ACK for %\"U32_F\"\\n\", pcb->rcv_nxt));\n  480    /* remove ACK flags from the PCB, as we send an empty ACK now */\n  481:   pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n  482  \n  483    tcphdr = tcp_output_set_header(pcb, p, optlen, htonl(pcb->snd_nxt));\n  ...\n  582      /* Stop sending if the nagle algorithm would prevent it\n  583       * Don't stop:\n  584:      * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or\n  585       * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -\n  586       *   either seg->next != NULL or pcb->unacked == NULL;\n  ...\n  604      if (pcb->state != SYN_SENT) {\n  605        TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);\n  606:       pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n  607      }\n  608  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\include\\ipv4\\lwip\\autoip.h:\n   62  \n   63  /* RFC 3927 Constants */\n   64: #define PROBE_WAIT               1   /* second   (initial random delay)                 */\n   65: #define PROBE_MIN                1   /* second   (minimum delay till repeated probe)    */\n   66: #define PROBE_MAX                2   /* seconds  (maximum delay till repeated probe)    */\n   67  #define PROBE_NUM                3   /*          (number of probe packets)              */\n   68  #define ANNOUNCE_NUM             2   /*          (number of announcement packets)       */\n   69  #define ANNOUNCE_INTERVAL        2   /* seconds  (time between announcement packets)    */\n   70: #define ANNOUNCE_WAIT            2   /* seconds  (delay before announcing)              */\n   71  #define MAX_CONFLICTS            10  /*          (max conflicts before rate limiting)   */\n   72: #define RATE_LIMIT_INTERVAL      60  /* seconds  (delay between successive attempts)    */\n   73  #define DEFEND_INTERVAL          10  /* seconds  (min. wait between defensive ARPs)     */\n   74  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\include\\ipv4\\lwip\\igmp.h:\n   66  /* IGMP timer */\n   67  #define IGMP_TMR_INTERVAL              100 /* Milliseconds */\n   68: #define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)\n   69: #define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)\n   70  \n   71  /* MAC Filter Actions */\n   ..\n   75  /* Group  membership states */\n   76  #define IGMP_GROUP_NON_MEMBER          0\n   77: #define IGMP_GROUP_DELAYING_MEMBER     1\n   78  #define IGMP_GROUP_IDLE_MEMBER         2\n   79  \n   ..\n  148  void   igmp_stop_timer( struct igmp_group *group);\n  149  \n  150: void   igmp_delaying_member( struct igmp_group *group, u8_t maxresp);\n  151  \n  152  err_t  igmp_ip_output_if( struct pbuf *p, struct ip_addr *src, struct ip_addr *dest, u8_t ttl, u8_t proto, struct netif *netif);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\include\\lwip\\api.h:\n  152        this temporarily stores whether to wake up the original application task\n  153        if data couldn't be sent in the first try. */\n  154:   u8_t write_delayed;\n  155  #endif /* LWIP_TCPIP_CORE_LOCKING */\n  156  #endif /* LWIP_TCP */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\include\\lwip\\sockets.h:\n  145   * Options for level IPPROTO_TCP\n  146   */\n  147: #define TCP_NODELAY    0x01    /* don't delay send to coalesce packets */\n  148  #define TCP_KEEPALIVE  0x02    /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */\n  149  #define TCP_KEEPIDLE   0x03    /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */\n  ...\n  185   * precedence traffic as more important than other traffic (generally\n  186   * by accepting only traffic above a certain precedence at time of high\n  187:  * load).  The major choice is a three way tradeoff between low-delay,\n  188   * high-reliability, and high-throughput.\n  189:  * The use of the Delay, Throughput, and Reliability indications may\n  190   * increase the cost (in some sense) of the service.  In many networks\n  191   * better performance for one of these parameters is coupled with worse\n  ...\n  195  #define IPTOS_TOS_MASK          0x1E\n  196  #define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)\n  197: #define IPTOS_LOWDELAY          0x10\n  198  #define IPTOS_THROUGHPUT        0x08\n  199  #define IPTOS_RELIABILITY       0x04\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.3.2\\src\\include\\lwip\\tcp.h:\n   79  #define          tcp_mss(pcb)      ((pcb)->mss)\n   80  #define          tcp_sndbuf(pcb)   ((pcb)->snd_buf)\n   81: #define          tcp_nagle_disable(pcb)  ((pcb)->flags |= TF_NODELAY)\n   82: #define          tcp_nagle_enable(pcb) ((pcb)->flags &= ~TF_NODELAY)\n   83: #define          tcp_nagle_disabled(pcb) (((pcb)->flags & TF_NODELAY) != 0)\n   84  \n   85  #if TCP_LISTEN_BACKLOG\n   ..\n  137   * segments as possible. Only send if\n  138   * - no previously transmitted data on the connection remains unacknowledged or\n  139:  * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or\n  140   * - the only unsent segment is at least pcb->mss bytes long (or there is more\n  141   *   than one unsent segment - with lwIP, this can happen although unsent->len < mss)\n  ...\n  143   */\n  144  #define tcp_do_output_nagle(tpcb) ((((tpcb)->unacked == NULL) || \\\n  145:                             ((tpcb)->flags & (TF_NODELAY | TF_INFR)) || \\\n  146                              (((tpcb)->unsent != NULL) && (((tpcb)->unsent->next != NULL) || \\\n  147                                ((tpcb)->unsent->len >= (tpcb)->mss))) \\\n  ...\n  302    \n  303    u8_t flags;\n  304: #define TF_ACK_DELAY   ((u8_t)0x01U)   /* Delayed ACK. */\n  305  #define TF_ACK_NOW     ((u8_t)0x02U)   /* Immediate ACK. */\n  306  #define TF_INFR        ((u8_t)0x04U)   /* In fast recovery. */\n  307  #define TF_TIMESTAMP   ((u8_t)0x08U)   /* Timestamp option enabled */\n  308  #define TF_FIN         ((u8_t)0x20U)   /* Connection was closed locally (FIN segment enqueued). */\n  309: #define TF_NODELAY     ((u8_t)0x40U)   /* Disable Nagle algorithm */\n  310: #define TF_NAGLEMEMERR ((u8_t)0x80U)   /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */\n  311  \n  312    /* the rest of the fields are in host byte order\n  ...\n  554  #define tcp_ack(pcb)                               \\\n  555    do {                                             \\\n  556:     if((pcb)->flags & TF_ACK_DELAY) {              \\\n  557:       (pcb)->flags &= ~TF_ACK_DELAY;               \\\n  558        (pcb)->flags |= TF_ACK_NOW;                  \\\n  559        tcp_output(pcb);                             \\\n  560      }                                              \\\n  561      else {                                         \\\n  562:       (pcb)->flags |= TF_ACK_DELAY;                \\\n  563      }                                              \\\n  564    } while (0)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\core\\ipv4\\igmp.c:\n  114  /* Group  membership states */\n  115  #define IGMP_GROUP_NON_MEMBER          0\n  116: #define IGMP_GROUP_DELAYING_MEMBER     1\n  117  #define IGMP_GROUP_IDLE_MEMBER         2\n  118  \n  ...\n  140  static void   igmp_timeout( struct igmp_group *group);\n  141  static void   igmp_start_timer(struct igmp_group *group, u8_t max_time);\n  142: static void   igmp_delaying_member(struct igmp_group *group, u8_t maxresp);\n  143  static err_t  igmp_ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, struct netif *netif);\n  144  static void   igmp_send(struct igmp_group *group, u8_t type);\n  ...\n  273    while (group != NULL) {\n  274      if (group->netif == netif) {\n  275:       igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n  276      }\n  277      group = group->next;\n  ...\n  442           IGMP_STATS_INC(igmp.rx_v1);\n  443           LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\\n\"));\n  444:          igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;\n  445         } else {\n  446           IGMP_STATS_INC(igmp.rx_general);\n  ...\n  451           /* Do not send messages on the all systems group address! */\n  452           if ((groupref->netif == inp) && (!(ip_addr_cmp(&(groupref->group_address), &allsystems)))) {\n  453:            igmp_delaying_member(groupref, igmp->igmp_maxresp);\n  454           }\n  455           groupref = groupref->next;\n  ...\n  472           if (group != NULL) {\n  473             IGMP_STATS_INC(igmp.rx_group);\n  474:            igmp_delaying_member(group, igmp->igmp_maxresp);\n  475           } else {\n  476             IGMP_STATS_INC(igmp.drop);\n  ...\n  485       LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: IGMP_V2_MEMB_REPORT\\n\"));\n  486       IGMP_STATS_INC(igmp.rx_report);\n  487:      if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n  488         /* This is on a specific group we have already looked up */\n  489         group->timer = 0; /* stopped */\n  ...\n  552            igmp_send(group, IGMP_V2_MEMB_REPORT);\n  553  \n  554:           igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n  555  \n  556            /* Need to work out where this timer comes from */\n  557:           group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  558          }\n  559          /* Increment group use */\n  ...\n  677  igmp_timeout(struct igmp_group *group)\n  678  {\n  679:   /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */\n  680:   if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n  681      LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_timeout: report membership for group with address \"));\n  682      ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));\n  ...\n  707  \n  708  /**\n  709:  * Delaying membership report for a group if necessary\n  710   *\n  711:  * @param group the igmp_group for which \"delaying\" membership report\n  712:  * @param maxresp query delay\n  713   */\n  714  static void\n  715: igmp_delaying_member(struct igmp_group *group, u8_t maxresp)\n  716  {\n  717    if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||\n  718:      ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&\n  719        ((group->timer == 0) || (maxresp < group->timer)))) {\n  720      igmp_start_timer(group, maxresp);\n  721:     group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  722    }\n  723  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\core\\sys.c:\n   56  {\n   57    if (ms > 0) {\n   58:     sys_sem_t delaysem;\n   59:     err_t err = sys_sem_new(&delaysem, 0);\n   60      if (err == ERR_OK) {\n   61:       sys_arch_sem_wait(&delaysem, ms);\n   62:       sys_sem_free(&delaysem);\n   63      }\n   64    }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\core\\tcp.c:\n 1039  /**\n 1040   * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously\n 1041:  * \"refused\" by upper layer (application) and sends delayed ACKs.\n 1042   *\n 1043   * Automatically called from tcp_tmr().\n ....\n 1057        struct tcp_pcb *next;\n 1058        pcb->last_timer = tcp_timer_ctr;\n 1059:       /* send delayed ACKs */\n 1060:       if (pcb->flags & TF_ACK_DELAY) {\n 1061:         LWIP_DEBUGF(TCP_DEBUG, (\"tcp_fasttmr: delayed ACK\\n\"));\n 1062          tcp_ack_now(pcb);\n 1063          tcp_output(pcb);\n 1064:         pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n 1065        }\n 1066  \n ....\n 1530  \n 1531  /**\n 1532:  * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.\n 1533   *\n 1534   * @param pcblist PCB list to purge.\n ....\n 1542    tcp_pcb_purge(pcb);\n 1543    \n 1544:   /* if there is an outstanding delayed ACKs, send it */\n 1545    if (pcb->state != TIME_WAIT &&\n 1546       pcb->state != LISTEN &&\n 1547:      pcb->flags & TF_ACK_DELAY) {\n 1548      pcb->flags |= TF_ACK_NOW;\n 1549      tcp_output(pcb);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\core\\tcp_in.c:\n  364          if (recv_flags & TF_GOT_FIN) {\n  365            if (pcb->refused_data != NULL) {\n  366:             /* Delay this if we have refused data. */\n  367              pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;\n  368            } else {\n  ...\n  599        LWIP_ASSERT(\"tcp_input: pcb->state != CLOSED\", pcb->state != CLOSED);\n  600        recv_flags |= TF_RESET;\n  601:       pcb->flags &= ~TF_ACK_DELAY;\n  602        return ERR_RST;\n  603      } else {\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\core\\tcp_out.c:\n  245       */\n  246      if ((apiflags & TCP_WRITE_FLAG_MORE) ||\n  247:         (!(pcb->flags & TF_NODELAY) &&\n  248           (!first_seg ||\n  249            pcb->unsent != NULL ||\n  ...\n  861                (\"tcp_output: sending ACK for %\"U32_F\"\\n\", pcb->rcv_nxt));\n  862    /* remove ACK flags from the PCB, as we send an empty ACK now */\n  863:   pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n  864  \n  865    /* NB. MSS option is only sent on SYNs, so ignore it here */\n  ...\n  966      /* Stop sending if the nagle algorithm would prevent it\n  967       * Don't stop:\n  968:      * - if tcp_write had a memory error before (prevent delayed ACK timeout) or\n  969       * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -\n  970       *   either seg->next != NULL or pcb->unacked == NULL;\n  ...\n  988      if (pcb->state != SYN_SENT) {\n  989        TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);\n  990:       pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n  991      }\n  992  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\include\\ipv4\\lwip\\autoip.h:\n   62  \n   63  /* RFC 3927 Constants */\n   64: #define PROBE_WAIT               1   /* second   (initial random delay)                 */\n   65: #define PROBE_MIN                1   /* second   (minimum delay till repeated probe)    */\n   66: #define PROBE_MAX                2   /* seconds  (maximum delay till repeated probe)    */\n   67  #define PROBE_NUM                3   /*          (number of probe packets)              */\n   68  #define ANNOUNCE_NUM             2   /*          (number of announcement packets)       */\n   69  #define ANNOUNCE_INTERVAL        2   /* seconds  (time between announcement packets)    */\n   70: #define ANNOUNCE_WAIT            2   /* seconds  (delay before announcing)              */\n   71  #define MAX_CONFLICTS            10  /*          (max conflicts before rate limiting)   */\n   72: #define RATE_LIMIT_INTERVAL      60  /* seconds  (delay between successive attempts)    */\n   73  #define DEFEND_INTERVAL          10  /* seconds  (min. wait between defensive ARPs)     */\n   74  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\include\\ipv4\\lwip\\igmp.h:\n   50  /* IGMP timer */\n   51  #define IGMP_TMR_INTERVAL              100 /* Milliseconds */\n   52: #define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)\n   53: #define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)\n   54  \n   55  /* MAC Filter Actions, these are passed to a netif's\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\include\\lwip\\api.h:\n   63      this temporarily stores whether to wake up the original application task\n   64      if data couldn't be sent in the first try. */\n   65: #define NETCONN_FLAG_WRITE_DELAYED            0x01\n   66  /** Should this netconn avoid blocking? */\n   67  #define NETCONN_FLAG_NON_BLOCKING             0x02\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\include\\lwip\\sockets.h:\n  147   * Options for level IPPROTO_TCP\n  148   */\n  149: #define TCP_NODELAY    0x01    /* don't delay send to coalesce packets */\n  150  #define TCP_KEEPALIVE  0x02    /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */\n  151  #define TCP_KEEPIDLE   0x03    /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */\n  ...\n  187   * precedence traffic as more important than other traffic (generally\n  188   * by accepting only traffic above a certain precedence at time of high\n  189:  * load).  The major choice is a three way tradeoff between low-delay,\n  190   * high-reliability, and high-throughput.\n  191:  * The use of the Delay, Throughput, and Reliability indications may\n  192   * increase the cost (in some sense) of the service.  In many networks\n  193   * better performance for one of these parameters is coupled with worse\n  ...\n  197  #define IPTOS_TOS_MASK          0x1E\n  198  #define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)\n  199: #define IPTOS_LOWDELAY          0x10\n  200  #define IPTOS_THROUGHPUT        0x08\n  201  #define IPTOS_RELIABILITY       0x04\n  ...\n  278  #define O_NONBLOCK  1 /* nonblocking I/O */\n  279  #endif\n  280: #ifndef O_NDELAY\n  281: #define O_NDELAY    1 /* same as O_NONBLOCK, for compatibility */\n  282  #endif\n  283  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\include\\lwip\\tcp.h:\n  176    \n  177    u8_t flags;\n  178: #define TF_ACK_DELAY   ((u8_t)0x01U)   /* Delayed ACK. */\n  179  #define TF_ACK_NOW     ((u8_t)0x02U)   /* Immediate ACK. */\n  180  #define TF_INFR        ((u8_t)0x04U)   /* In fast recovery. */\n  ...\n  182  #define TF_RXCLOSED    ((u8_t)0x10U)   /* rx closed by tcp_shutdown */\n  183  #define TF_FIN         ((u8_t)0x20U)   /* Connection was closed locally (FIN segment enqueued). */\n  184: #define TF_NODELAY     ((u8_t)0x40U)   /* Disable Nagle algorithm */\n  185: #define TF_NAGLEMEMERR ((u8_t)0x80U)   /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */\n  186  \n  187    /* the rest of the fields are in host byte order\n  ...\n  326  #define          tcp_sndbuf(pcb)          ((pcb)->snd_buf)\n  327  #define          tcp_sndqueuelen(pcb)     ((pcb)->snd_queuelen)\n  328: #define          tcp_nagle_disable(pcb)   ((pcb)->flags |= TF_NODELAY)\n  329: #define          tcp_nagle_enable(pcb)    ((pcb)->flags &= ~TF_NODELAY)\n  330: #define          tcp_nagle_disabled(pcb)  (((pcb)->flags & TF_NODELAY) != 0)\n  331  \n  332  #if TCP_LISTEN_BACKLOG\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\src\\include\\lwip\\tcp_impl.h:\n   77   * segments as possible. Only send if\n   78   * - no previously transmitted data on the connection remains unacknowledged or\n   79:  * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or\n   80   * - the only unsent segment is at least pcb->mss bytes long (or there is more\n   81   *   than one unsent segment - with lwIP, this can happen although unsent->len < mss)\n   ..\n   83   */\n   84  #define tcp_do_output_nagle(tpcb) ((((tpcb)->unacked == NULL) || \\\n   85:                             ((tpcb)->flags & (TF_NODELAY | TF_INFR)) || \\\n   86                              (((tpcb)->unsent != NULL) && (((tpcb)->unsent->next != NULL) || \\\n   87                                ((tpcb)->unsent->len >= (tpcb)->mss))) || \\\n   ..\n  423  #define tcp_ack(pcb)                               \\\n  424    do {                                             \\\n  425:     if((pcb)->flags & TF_ACK_DELAY) {              \\\n  426:       (pcb)->flags &= ~TF_ACK_DELAY;               \\\n  427        (pcb)->flags |= TF_ACK_NOW;                  \\\n  428      }                                              \\\n  429      else {                                         \\\n  430:       (pcb)->flags |= TF_ACK_DELAY;                \\\n  431      }                                              \\\n  432    } while (0)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip-1.4.1\\test\\unit\\tcp\\test_tcp_oos.c:\n  720   * - 2nd FIN (invalid)\n  721   *\n  722:  * the parameter 'delay_packet' is a bitmask that choses which on these packets is ooseq\n  723   */\n  724: static void test_tcp_recv_ooseq_double_FINs(int delay_packet)\n  725  {\n  726    int i, k;\n  ...\n  761    p_2nd_fin_ooseq = tcp_create_rx_segment(pcb, NULL, 0, TCP_MSS+1+k, 0, TCP_ACK|TCP_FIN);\n  762  \n  763:   if(delay_packet & 1) {\n  764      /* drop normal data */\n  765      first_dropped = 1;\n  ...\n  774    check_rx_counters(pcb, &counters, exp_close_calls, exp_rx_calls, exp_rx_bytes, 0, exp_oos_pbufs, exp_oos_tcplen);\n  775  \n  776:   if(delay_packet & 2) {\n  777      /* drop FIN */\n  778      if(first_dropped > 2) {\n  ...\n  795    check_rx_counters(pcb, &counters, exp_close_calls, exp_rx_calls, exp_rx_bytes, 0, exp_oos_pbufs, exp_oos_tcplen);\n  796  \n  797:   if(delay_packet & 4) {\n  798      /* drop data-after-FIN */\n  799      if(first_dropped > 3) {\n  ...\n  806      if (first_dropped < 3) {\n  807        /* already dropped packets, this one is ooseq */\n  808:       if (delay_packet & 2) {\n  809          /* correct FIN was ooseq */\n  810          exp_oos_pbufs++;\n  ...\n  818    check_rx_counters(pcb, &counters, exp_close_calls, exp_rx_calls, exp_rx_bytes, 0, exp_oos_pbufs, exp_oos_tcplen);\n  819  \n  820:   if(delay_packet & 8) {\n  821      /* drop 2nd-FIN */\n  822      if(first_dropped > 4) {\n  ...\n  829      if (first_dropped < 3) {\n  830        /* already dropped packets, this one is ooseq */\n  831:       if (delay_packet & 2) {\n  832          /* correct FIN was ooseq */\n  833          exp_oos_pbufs++;\n  ...\n  841    check_rx_counters(pcb, &counters, exp_close_calls, exp_rx_calls, exp_rx_bytes, 0, exp_oos_pbufs, exp_oos_tcplen);\n  842  \n  843:   if(delay_packet & 1) {\n  844      /* dropped normal data before */\n  845      test_tcp_input(p, &netif);\n  846      exp_rx_calls++;\n  847      exp_rx_bytes += TCP_MSS;\n  848:     if((delay_packet & 2) == 0) {\n  849:       /* normal FIN was NOT delayed */\n  850        exp_close_calls++;\n  851        exp_oos_pbufs = exp_oos_tcplen = 0;\n  ...\n  855    check_rx_counters(pcb, &counters, exp_close_calls, exp_rx_calls, exp_rx_bytes, 0, exp_oos_pbufs, exp_oos_tcplen);\n  856  \n  857:   if(delay_packet & 2) {\n  858      /* dropped normal FIN before */\n  859      test_tcp_input(p_normal_fin, &netif);\n  ...\n  864    check_rx_counters(pcb, &counters, exp_close_calls, exp_rx_calls, exp_rx_bytes, 0, exp_oos_pbufs, exp_oos_tcplen);\n  865  \n  866:   if(delay_packet & 4) {\n  867      /* dropped data-after-FIN before */\n  868      test_tcp_input(p_data_after_fin, &netif);\n  ...\n  871    check_rx_counters(pcb, &counters, exp_close_calls, exp_rx_calls, exp_rx_bytes, 0, exp_oos_pbufs, exp_oos_tcplen);\n  872  \n  873:   if(delay_packet & 8) {\n  874      /* dropped 2nd-FIN before */\n  875      test_tcp_input(p_2nd_fin_ooseq, &netif);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\apps\\ping.c:\n   23  /** ping receive timeout - in milliseconds */\n   24  #define PING_RCV_TIMEO 1000\n   25: /** ping delay - in milliseconds */\n   26: #define PING_DELAY     100\n   27  \n   28  /** ping identifier - must fit on a u16_t */\n   ..\n  165  		if (send_time >= time) break; /* send ping times reached, stop */\n  166  \n  167: 		rt_thread_delay(PING_DELAY); /* take a delay */\n  168  	}\n  169  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\apps\\sntp.c:\n   67  #endif\n   68  \n   69: /** SNTP update delay - in milliseconds */\n   70: #ifndef SNTP_UPDATE_DELAY\n   71: #define SNTP_UPDATE_DELAY           60000\n   72  #endif\n   73  \n   ..\n  204  	{\n  205  		sntp_request();\n  206: 		sys_msleep(SNTP_UPDATE_DELAY);\n  207  	}\n  208  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\core\\ipv4\\igmp.c:\n  114  /* Group  membership states */\n  115  #define IGMP_GROUP_NON_MEMBER          0\n  116: #define IGMP_GROUP_DELAYING_MEMBER     1\n  117  #define IGMP_GROUP_IDLE_MEMBER         2\n  118  \n  ...\n  141  static void   igmp_start_timer(struct igmp_group *group, u8_t max_time);\n  142  static void   igmp_stop_timer(struct igmp_group *group);\n  143: static void   igmp_delaying_member(struct igmp_group *group, u8_t maxresp);\n  144  static err_t  igmp_ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, struct netif *netif);\n  145  static void   igmp_send(struct igmp_group *group, u8_t type);\n  ...\n  274    while (group != NULL) {\n  275      if (group->netif == netif) {\n  276:       igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n  277      }\n  278      group = group->next;\n  ...\n  443           IGMP_STATS_INC(igmp.rx_v1);\n  444           LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\\n\"));\n  445:          igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;\n  446         } else {\n  447           IGMP_STATS_INC(igmp.rx_general);\n  ...\n  452           /* Do not send messages on the all systems group address! */\n  453           if ((groupref->netif == inp) && (!(ip_addr_cmp(&(groupref->group_address), &allsystems)))) {\n  454:            igmp_delaying_member(groupref, igmp->igmp_maxresp);\n  455           }\n  456           groupref = groupref->next;\n  ...\n  473           if (group != NULL) {\n  474             IGMP_STATS_INC(igmp.rx_group);\n  475:            igmp_delaying_member(group, igmp->igmp_maxresp);\n  476           } else {\n  477             IGMP_STATS_INC(igmp.drop);\n  ...\n  486       LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_input: IGMP_V2_MEMB_REPORT\\n\"));\n  487       IGMP_STATS_INC(igmp.rx_report);\n  488:      if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n  489         /* This is on a specific group we have already looked up */\n  490         group->timer = 0; /* stopped */\n  ...\n  553            igmp_send(group, IGMP_V2_MEMB_REPORT);\n  554  \n  555:           igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n  556  \n  557            /* Need to work out where this timer comes from */\n  558:           group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  559          }\n  560          /* Increment group use */\n  ...\n  678  igmp_timeout(struct igmp_group *group)\n  679  {\n  680:   /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */\n  681:   if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n  682      LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_timeout: report membership for group with address \"));\n  683      ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));\n  ...\n  719  \n  720  /**\n  721:  * Delaying membership report for a group if necessary\n  722   *\n  723:  * @param group the igmp_group for which \"delaying\" membership report\n  724:  * @param maxresp query delay\n  725   */\n  726  static void\n  727: igmp_delaying_member(struct igmp_group *group, u8_t maxresp)\n  728  {\n  729    if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||\n  730:      ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&\n  731        ((group->timer == 0) || (maxresp < group->timer)))) {\n  732      igmp_start_timer(group, maxresp);\n  733:     group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  734    }\n  735  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\core\\sys.c:\n   55  {\n   56    if (ms > 0) {\n   57:     sys_sem_t delaysem;\n   58:     err_t err = sys_sem_new(&delaysem, 0);\n   59      if (err == ERR_OK) {\n   60:       sys_arch_sem_wait(&delaysem, ms);\n   61:       sys_sem_free(&delaysem);\n   62      }\n   63    }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\core\\tcp.c:\n  986  /**\n  987   * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously\n  988:  * \"refused\" by upper layer (application) and sends delayed ACKs.\n  989   *\n  990   * Automatically called from tcp_tmr().\n  ...\n 1011      }\n 1012  \n 1013:     /* send delayed ACKs */\n 1014:     if (pcb && (pcb->flags & TF_ACK_DELAY)) {\n 1015:       LWIP_DEBUGF(TCP_DEBUG, (\"tcp_fasttmr: delayed ACK\\n\"));\n 1016        tcp_ack_now(pcb);\n 1017        tcp_output(pcb);\n 1018:       pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n 1019      }\n 1020  \n ....\n 1423  \n 1424  /**\n 1425:  * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.\n 1426   *\n 1427   * @param pcblist PCB list to purge.\n ....\n 1435    tcp_pcb_purge(pcb);\n 1436    \n 1437:   /* if there is an outstanding delayed ACKs, send it */\n 1438    if (pcb->state != TIME_WAIT &&\n 1439       pcb->state != LISTEN &&\n 1440:      pcb->flags & TF_ACK_DELAY) {\n 1441      pcb->flags |= TF_ACK_NOW;\n 1442      tcp_output(pcb);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\core\\tcp_in.c:\n  596        LWIP_ASSERT(\"tcp_input: pcb->state != CLOSED\", pcb->state != CLOSED);\n  597        recv_flags |= TF_RESET;\n  598:       pcb->flags &= ~TF_ACK_DELAY;\n  599        return ERR_RST;\n  600      } else {\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\core\\tcp_out.c:\n  242       */\n  243      if ((apiflags & TCP_WRITE_FLAG_MORE) ||\n  244:         (!(pcb->flags & TF_NODELAY) &&\n  245           (!first_seg ||\n  246            pcb->unsent != NULL ||\n  ...\n  855                (\"tcp_output: sending ACK for %\"U32_F\"\\n\", pcb->rcv_nxt));\n  856    /* remove ACK flags from the PCB, as we send an empty ACK now */\n  857:   pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n  858  \n  859    /* NB. MSS option is only sent on SYNs, so ignore it here */\n  ...\n  956      /* Stop sending if the nagle algorithm would prevent it\n  957       * Don't stop:\n  958:      * - if tcp_write had a memory error before (prevent delayed ACK timeout) or\n  959       * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -\n  960       *   either seg->next != NULL or pcb->unacked == NULL;\n  ...\n  978      if (pcb->state != SYN_SENT) {\n  979        TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);\n  980:       pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n  981      }\n  982  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\include\\ipv4\\lwip\\autoip.h:\n   62  \n   63  /* RFC 3927 Constants */\n   64: #define PROBE_WAIT               1   /* second   (initial random delay)                 */\n   65: #define PROBE_MIN                1   /* second   (minimum delay till repeated probe)    */\n   66: #define PROBE_MAX                2   /* seconds  (maximum delay till repeated probe)    */\n   67  #define PROBE_NUM                3   /*          (number of probe packets)              */\n   68  #define ANNOUNCE_NUM             2   /*          (number of announcement packets)       */\n   69  #define ANNOUNCE_INTERVAL        2   /* seconds  (time between announcement packets)    */\n   70: #define ANNOUNCE_WAIT            2   /* seconds  (delay before announcing)              */\n   71  #define MAX_CONFLICTS            10  /*          (max conflicts before rate limiting)   */\n   72: #define RATE_LIMIT_INTERVAL      60  /* seconds  (delay between successive attempts)    */\n   73  #define DEFEND_INTERVAL          10  /* seconds  (min. wait between defensive ARPs)     */\n   74  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\include\\ipv4\\lwip\\igmp.h:\n   50  /* IGMP timer */\n   51  #define IGMP_TMR_INTERVAL              100 /* Milliseconds */\n   52: #define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)\n   53: #define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)\n   54  \n   55  /* MAC Filter Actions, these are passed to a netif's\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\include\\lwip\\api.h:\n   63      this temporarily stores whether to wake up the original application task\n   64      if data couldn't be sent in the first try. */\n   65: #define NETCONN_FLAG_WRITE_DELAYED            0x01\n   66  /** Should this netconn avoid blocking? */\n   67  #define NETCONN_FLAG_NON_BLOCKING             0x02\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\include\\lwip\\sockets.h:\n  145   * Options for level IPPROTO_TCP\n  146   */\n  147: #define TCP_NODELAY    0x01    /* don't delay send to coalesce packets */\n  148  #define TCP_KEEPALIVE  0x02    /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */\n  149  #define TCP_KEEPIDLE   0x03    /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */\n  ...\n  185   * precedence traffic as more important than other traffic (generally\n  186   * by accepting only traffic above a certain precedence at time of high\n  187:  * load).  The major choice is a three way tradeoff between low-delay,\n  188   * high-reliability, and high-throughput.\n  189:  * The use of the Delay, Throughput, and Reliability indications may\n  190   * increase the cost (in some sense) of the service.  In many networks\n  191   * better performance for one of these parameters is coupled with worse\n  ...\n  195  #define IPTOS_TOS_MASK          0x1E\n  196  #define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)\n  197: #define IPTOS_LOWDELAY          0x10\n  198  #define IPTOS_THROUGHPUT        0x08\n  199  #define IPTOS_RELIABILITY       0x04\n  ...\n  276  #define O_NONBLOCK  1 /* nonblocking I/O */\n  277  #endif\n  278: #ifndef O_NDELAY\n  279: #define O_NDELAY    1 /* same as O_NONBLOCK, for compatibility */\n  280  #endif\n  281  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\include\\lwip\\tcp.h:\n  177    \n  178    u8_t flags;\n  179: #define TF_ACK_DELAY   ((u8_t)0x01U)   /* Delayed ACK. */\n  180  #define TF_ACK_NOW     ((u8_t)0x02U)   /* Immediate ACK. */\n  181  #define TF_INFR        ((u8_t)0x04U)   /* In fast recovery. */\n  ...\n  183  #define TF_RXCLOSED    ((u8_t)0x10U)   /* rx closed by tcp_shutdown */\n  184  #define TF_FIN         ((u8_t)0x20U)   /* Connection was closed locally (FIN segment enqueued). */\n  185: #define TF_NODELAY     ((u8_t)0x40U)   /* Disable Nagle algorithm */\n  186: #define TF_NAGLEMEMERR ((u8_t)0x80U)   /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */\n  187  \n  188    /* the rest of the fields are in host byte order\n  ...\n  324  #define          tcp_sndbuf(pcb)          ((pcb)->snd_buf)\n  325  #define          tcp_sndqueuelen(pcb)     ((pcb)->snd_queuelen)\n  326: #define          tcp_nagle_disable(pcb)   ((pcb)->flags |= TF_NODELAY)\n  327: #define          tcp_nagle_enable(pcb)    ((pcb)->flags &= ~TF_NODELAY)\n  328: #define          tcp_nagle_disabled(pcb)  (((pcb)->flags & TF_NODELAY) != 0)\n  329  \n  330  #if TCP_LISTEN_BACKLOG\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\lwip\\src\\include\\lwip\\tcp_impl.h:\n   77   * segments as possible. Only send if\n   78   * - no previously transmitted data on the connection remains unacknowledged or\n   79:  * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or\n   80   * - the only unsent segment is at least pcb->mss bytes long (or there is more\n   81   *   than one unsent segment - with lwIP, this can happen although unsent->len < mss)\n   ..\n   83   */\n   84  #define tcp_do_output_nagle(tpcb) ((((tpcb)->unacked == NULL) || \\\n   85:                             ((tpcb)->flags & (TF_NODELAY | TF_INFR)) || \\\n   86                              (((tpcb)->unsent != NULL) && (((tpcb)->unsent->next != NULL) || \\\n   87                                ((tpcb)->unsent->len >= (tpcb)->mss))) \\\n   ..\n  408  #define tcp_ack(pcb)                               \\\n  409    do {                                             \\\n  410:     if((pcb)->flags & TF_ACK_DELAY) {              \\\n  411:       (pcb)->flags &= ~TF_ACK_DELAY;               \\\n  412        (pcb)->flags |= TF_ACK_NOW;                  \\\n  413      }                                              \\\n  414      else {                                         \\\n  415:       (pcb)->flags |= TF_ACK_DELAY;                \\\n  416      }                                              \\\n  417    } while (0)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\uip\\rt-thread\\uIPmain.c:\n   71      while(1)\n   72      {\n   73:         rt_thread_delay(CLOCK_SECOND*5);\n   74          for (i = 0; i < UIP_CONNS; i++) \n   75          {\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\net\\uip\\uip\\uip-split.h:\n   44   * The basic uIP TCP implementation only allows each TCP connection to\n   45   * have a single TCP segment in flight at any given time. Because of\n   46:  * the delayed ACK algorithm employed by most TCP receivers, uIP's\n   47   * limit on the amount of in-flight TCP segments seriously reduces the\n   48   * maximum achievable throughput for sending data from uIP.\n   ..\n   50   * The uip-split module is a hack which tries to remedy this\n   51   * situation. By splitting maximum sized outgoing TCP segments into\n   52:  * two, the delayed ACK algorithm is not invoked at TCP\n   53   * receivers. This improves the throughput when sending data from uIP\n   54   * by orders of magnitude.\n   ..\n   64   * \\file\n   65   * Module for splitting outbound TCP segments in two to avoid the\n   66:  * delayed ACK throughput degradation.\n   67   * \\author\n   68   * Adam Dunkels <adam@sics.se>\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\utilities\\zmodem\\rz.c:\n   78  	rt_free(zf);\n   79  	/* waiting,clear console buffer */\n   80: 	rt_thread_delay(RT_TICK_PER_SECOND/2);\n   81  	while(1)                     \n   82  	{\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\components\\utilities\\zmodem\\zdevice.c:\n   92  			 continue;\n   93  		case '\\335':\n   94: 		     rt_thread_delay(RT_TICK_PER_SECOND);\n   95  			 continue;\n   96  		default:\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\event_simple.c:\n   33  		}\n   34  \n   35: 		rt_kprintf(\"thread1: delay 1s to prepare second event\\n\");\n   36: 		rt_thread_delay(10);\n   37  \n   38  		/* receive second event */\n   ..\n   44  		}\n   45  \n   46: 		rt_thread_delay(5);\n   47  	}\n   48  }\n   ..\n   56  		rt_event_send(&event, (1 << 3));\n   57  \n   58: 		rt_thread_delay(10);\n   59  	}\n   60  }\n   ..\n   68  		rt_event_send(&event, (1 << 5));\n   69  \n   70: 		rt_thread_delay(20);\n   71  	}\n   72  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\mbox_send_wait.c:\n   33  \n   34  			/* 延时20个OS Tick */\n   35: 			rt_thread_delay(50);\n   36  		}\n   37  	}\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\mbox_simple.c:\n   35  \n   36  			/* 延时10个OS Tick */\n   37: 			rt_thread_delay(10);\n   38  		}\n   39  	}\n   ..\n   61  \n   62  		/* 延时20个OS Tick */\n   63: 		rt_thread_delay(20);\n   64  	}\n   65  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\memp_simple.c:\n   65  \n   66  		/* 休眠10个OS Tick */\n   67: 		rt_thread_delay(10);\n   68  	}\n   69  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\messageq_simple.c:\n   34  \n   35  		/* 延迟10个OS Tick */\n   36: 		rt_thread_delay(10);\n   37  	}\n   38  }\n   ..\n   56  			{\n   57  				/* 消息队列满， 延迟1s时间 */\n   58: 				rt_kprintf(\"message queue full, delay 1s\\n\");\n   59: 				rt_thread_delay(100);\n   60  			}\n   61  		}\n   62  \n   63  		/* 延时10个OS Tick */\n   64: 		rt_thread_delay(10);\n   65  	}\n   66  }\n   ..\n   79  \n   80  		/* 延时25个OS Tick */\n   81: 		rt_thread_delay(25);\n   82  	}\n   83  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\mutex_simple.c:\n   15  {\n   16  	/* 先让低优先级线程运行 */\n   17: 	rt_thread_delay(10);\n   18  \n   19  	/* 此时thread3持有mutex，并且thread2等待持有mutex */\n   ..\n   34  \n   35  	/* 先让低优先级线程运行 */\n   36: 	rt_thread_delay(5);\n   37  \n   38  	while (1)\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\semaphore_buffer_worker.c:\n  155  \n  156  		/* 做一个5 OS Tick的休眠 */\n  157: 		rt_thread_delay(5);\n  158  	}\n  159  }\n  ...\n  185  \n  186  		/* 放入成功，做一个10 OS Tick的休眠 */\n  187: 		rt_thread_delay(10);\n  188  	}\n  189  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\semaphore_priority.c:\n   43  static void worker_thread_entry(void* parameter)\n   44  {\n   45: 	rt_thread_delay(10);\n   46  \n   47  	while (1)\n   48  	{\n   49  		rt_sem_release(sem);\n   50: 		rt_thread_delay(5);\n   51  	}\n   52  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\semaphore_producer_consumer.c:\n   45  \n   46  		/* 暂停一段时间 */\n   47: 		rt_thread_delay(50);\n   48  	}\n   49  \n   ..\n   79  \n   80  		/* 暂停一小会时间 */\n   81: 		rt_thread_delay(10);\n   82  	}\n   83  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\tc_comm.c:\n   79  	_tc_stat &= ~TC_STAT_RUNNING;\n   80  \n   81: 	rt_thread_delay(RT_TICK_PER_SECOND/2);\n   82  	if (_tc_thread.stat != RT_THREAD_INIT)\n   83  	{\n   ..\n   92  		rt_exit_critical();\n   93  	}\n   94: 	rt_thread_delay(RT_TICK_PER_SECOND/2);\n   95  }\n   96  FINSH_FUNCTION_EXPORT(tc_stop, stop testcase thread);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_delay.c:\n    3  \n    4  /*\n    5:  * This is an example for delay thread\n    6   */\n    7  static struct rt_thread thread;\n    .\n   12  	rt_kprintf(\"thread inited ok\\n\");\n   13  \n   14: 	rt_kprintf(\"thread delay 10 tick\\n\");\n   15  	tick = rt_tick_get();\n   16: 	rt_thread_delay(10);\n   17  	if (rt_tick_get() - tick > 10)\n   18  	{\n   ..\n   21  	}\n   22  \n   23: 	rt_kprintf(\"thread delay 15 tick\\n\");\n   24  	tick = rt_tick_get();\n   25: 	rt_thread_delay(15);\n   26  	if (rt_tick_get() - tick > 15)\n   27  	{\n   ..\n   35  }\n   36  \n   37: rt_err_t thread_delay_init()\n   38  {\n   39  	rt_err_t result;\n   ..\n   54  \n   55  #ifdef RT_USING_TC\n   56: int _tc_thread_delay()\n   57  {\n   58: 	thread_delay_init();\n   59  \n   60  	return 30;\n   61  }\n   62: FINSH_FUNCTION_EXPORT(_tc_thread_delay, a thread delay test);\n   63  #else\n   64  int rt_application_init()\n   65  {\n   66: 	thread_delay_init();\n   67  \n   68  	return 0;\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_delete.c:\n   42  \n   43  	/* 线程2启动后先睡眠10个OS Tick */\n   44: 	rt_thread_delay(10);\n   45  \n   46  	/*\n   ..\n   54  	 * idle线程将执行真正的线程1控制块和线程栈的删除\n   55  	 */\n   56: 	rt_thread_delay(10);\n   57  }\n   58  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_detach.c:\n   34  \n   35  	/* 线程2启动后先睡眠10个OS Tick */\n   36: 	rt_thread_delay(10);\n   37  \n   38  	/*\n   ..\n   44  	 * 线程2继续休眠10个OS Tick然后退出\n   45  	 */\n   46: 	rt_thread_delay(10);\n   47  \n   48  	/*\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_dynamic.c:\n    5  {\n    6  	rt_kprintf(\"thread dynamicly created ok\\n\");\n    7: 	rt_thread_delay(10);\n    8  	rt_kprintf(\"thread exit\\n\");\n    9  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_dynamic_simple.c:\n   22  \n   23  		/* 休眠10个OS Tick */\n   24: 		rt_thread_delay(10);\n   25  	}\n   26  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_priority.c:\n   18  		rt_kprintf(\"count = %d\\n\", count);\n   19  \n   20: 		rt_thread_delay(10);\n   21  	}\n   22  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_resume.c:\n   42  {\n   43  	/* 延时10个OS Tick */\n   44: 	rt_thread_delay(10);\n   45  \n   46  	/* 唤醒线程1 */\n   ..\n   49  \n   50  	/* 延时10个OS Tick */\n   51: 	rt_thread_delay(10);\n   52  \n   53  	/* 线程2自动退出 */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_static.c:\n   10  {\n   11  	rt_kprintf(\"thread staticly inited ok\\n\");\n   12: 	rt_thread_delay(10);\n   13  	rt_kprintf(\"thread exit\\n\");\n   14  \n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_static_simple.c:\n   28  \n   29  		/* 休眠10个OS Tick */\n   30: 		rt_thread_delay(10);\n   31  	}\n   32  }\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\kernel\\thread_suspend.c:\n   26  {\n   27  	/* 延时10个OS Tick */\n   28: 	rt_thread_delay(10);\n   29  \n   30  	/* 挂起线程1 */\n   ..\n   32  \n   33  	/* 延时10个OS Tick */\n   34: 	rt_thread_delay(10);\n   35  \n   36  	/* 线程2自动退出 */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\network\\tcpsendpacket.c:\n   47  			rt_kprintf(\"TCP thread send error: %d\\n\", result);\n   48  			lwip_close(sock);	//¹Ø±ÕÁ¬½Ó£¬ÖØÐÂ´´½¨Á¬½Ó\n   49: 			rt_thread_delay(10);\n   50  			if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)\n   51  				rt_kprintf(\"TCP Socket error:%d\\n\",sock);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\examples\\network\\udpclient.c:\n   34  \n   35         /* 线程休眠一段时间 */\n   36:        rt_thread_delay(50);\n   37  \n   38         /* 计数值减一 */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\include\\rtthread.h:\n  136  \n  137  rt_err_t rt_thread_yield(void);\n  138: rt_err_t rt_thread_delay(rt_tick_t tick);\n  139  rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);\n  140  rt_err_t rt_thread_suspend(rt_thread_t thread);\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\libcpu\\arm\\s3c24x0\\s3c24x0.h:\n  459  #define ADCCON    (*(volatile unsigned *)0x58000000) //ADC control\n  460  #define ADCTSC    (*(volatile unsigned *)0x58000004) //ADC touch screen control\n  461: #define ADCDLY    (*(volatile unsigned *)0x58000008) //ADC start or Interval Delay\n  462  #define ADCDAT0   (*(volatile unsigned *)0x5800000c) //ADC conversion data 0\n  463  #define ADCDAT1   (*(volatile unsigned *)0x58000010) //ADC conversion data 1\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\libcpu\\mips\\common\\asm.h:\n   12   *\n   13   * Some of the routines below contain useless nops that will be optimized\n   14:  * away by gas in -O mode. These nops are however required to fill delay\n   15   * slots in noreorder mode.\n   16   */\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\src\\thread.c:\n   19   * 2006-09-03     Bernard      implement rt_thread_detach\n   20   * 2008-02-16     Bernard      fixed the rt_thread_timeout bug\n   21:  * 2010-03-21     Bernard      change the errno of rt_thread_delay/sleep to\n   22   *                             RT_EOK.\n   23   * 2010-11-10     Bernard      add cleanup callback function in thread exit.\n   ..\n  441  \n  442  /**\n  443:  * This function will let current thread delay for some ticks.\n  444   *\n  445:  * @param tick the delay ticks\n  446   *\n  447   * @return RT_EOK\n  448   */\n  449: rt_err_t rt_thread_delay(rt_tick_t tick)\n  450  {\n  451      return rt_thread_sleep(tick);\n  452  }\n  453: RTM_EXPORT(rt_thread_delay);\n  454  \n  455  /**\n\nD:\\GitHub\\EmbStd_STM32\\RT-Thread\\src\\timer.c:\n  551                  /* get the delta timeout tick */\n  552                  next_timeout = next_timeout - current_tick;\n  553:                 rt_thread_delay(next_timeout);\n  554              }\n  555          }\n\n846 matches across 133 files\n",
			"settings":
			{
				"buffer_size": 153354,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 311.0,
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"Package Control: Install Package",
				"Package Control: Install Package"
			],
			[
				"Package Control: In",
				"Package Control: Install Package"
			],
			[
				"",
				"CTags: Rebuild Tags"
			],
			[
				"Install ",
				"Package Control: Install Package"
			],
			[
				"Install",
				"Package Control: Install Package"
			],
			[
				"Install P",
				"Package Control: Install Package"
			],
			[
				"Install Package",
				"Package Control: Install Package"
			],
			[
				"Snippet: ",
				"Snippet: input - tel"
			]
		],
		"width": 528.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/D/WORK_GIT/A31S/A31S700/sch/.git/config",
		"/D/WORK_GIT/A10/A10970/sch/.git/config",
		"/D/WORK_GIT/A10/A10-C22/sch/.git/config",
		"/D/WORK_GIT/A10/A10-C21/sch/.git/config",
		"/D/WORK_GIT/A10/A10-C10/sch/.git/config",
		"/D/WORK_GIT/A10/A10-C20/sch/.git/config",
		"/D/ssh/id_rsa.pub",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/mini2440/dm9000.c",
		"/D/ssh/id_rsa",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/application.c",
		"/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/Printf.c",
		"/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/main.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/src/thread.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/i2c-stm32.c                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Cbsp%5Cstm32f10x%5Ci2c-stm32.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f40x/Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_exti.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c",
		"/C/Users/Administrator/Desktop/ir.txt",
		"/D/id_rsa.pub",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f40x/Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/i2c-stm32.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/gpio.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/sys_C13R_cfg.txt                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5CCFG%5CCFG%5Csys_C13R_cfg.txt",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/ir_stm32.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/ssd1289.c                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Cbsp%5Cstm32f10x%5Cssd1289.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/sys_C12R1_cfg.txt                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5CCFG%5CCFG%5Csys_C12R1_cfg.txt",
		"/D/360云盘/精品相片/WWW/2011-04-01结婚照/入册/.picasa.ini",
		"/C/Documents and Settings/smit/桌面/display_param.cfg",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/gpio.c                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5Cgpio.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/powerGps.c                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5CpowerGps.c",
		"/C/Documents and Settings/smit/桌面/CFG/CFG/sys_C12R1_cfg.txt",
		"/C/Documents and Settings/smit/桌面/CFG/CFG/sys_C13R_cfg.txt",
		"/C/Documents and Settings/smit/桌面/powerGps.c",
		"/C/Documents and Settings/smit/Application Data/Foxmail/FoxmailTemp(386)/powerGps.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/src/clock.c",
		"/C/Documents and Settings/smit/桌面/r.c",
		"/D/360云盘/STM32/remote.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/logcat.log                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5C%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E4%B9%8B%E5%90%8E%5Clogcat.log",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/logcat.log                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5C%E6%94%B6%E4%B8%8D%E5%88%B0%E4%BF%A1%E5%8F%B71%5Clogcat.log",
		"/C/Documents and Settings/smit/桌面/gpio.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/%E6%96%B0%E5%BB%BA+Text+File+Type.txt                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5C%E6%96%B0%E5%BB%BA+Text+File+Type.txt",
		"/C/Documents and Settings/smit/桌面/新建 Text File Type.txt",
		"/C/Documents and Settings/smit/桌面/收到信号之后/logcat.log",
		"/C/Documents and Settings/smit/桌面/收不到信号1/logcat.log",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/logcat.log                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5C20130701153747%5Clogcat.log",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/dmesg.log                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5C20130701164326%5C20130701164326%5Cdmesg.log",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/dmesg.log                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5C%E6%94%B6%E4%B8%8D%E5%88%B0%E4%BF%A1%E5%8F%B71%5Cdmesg.log",
		"/C/Documents and Settings/smit/桌面/收不到信号1/dmesg.log",
		"/C/Documents and Settings/smit/桌面/20130701164326/20130701164326/dmesg.log",
		"/C/Documents and Settings/smit/桌面/20130701153747/logcat.log",
		"/D/SecureCRT&FX/log/COM1-06-20-16.log",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/dmesg.log                C%3A%5CDocuments+and+Settings%5Csmit%5C%E6%A1%8C%E9%9D%A2%5C20130701153747%5Cdmesg.log",
		"/C/Documents and Settings/smit/桌面/20130701153747/dmesg.log",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/ConsoleActivity.java                D%3A%5C360%E4%BA%91%E7%9B%98%5CTMP%5Csmdt_com_c22%5Csrc%5Candroid_serialport_api%5Csample%5CConsoleActivity.java",
		"/D/360云盘/文档/sdmt_com/smdt_com/jni/SerialPort.c",
		"/D/360云盘/文档/sdmt_com/smdt_com/src/android_serialport_api/sample/Application.java",
		"/D/360云盘/文档/sdmt_com/smdt_com/src/android_serialport_api/sample/MainMenu.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/SendingVgaActivity.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/SendingHdmi2Activity.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/SendingHdmi1Activity.java",
		"/D/SecureCRT&FX/log/COM1-06-20-16-2.log",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/MainMenu.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/SerialPortActivity.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/LoopbackActivity.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/Application.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/SerialPortPreferences.java",
		"/D/360云盘/TMP/smdt_com_c22/src/android_serialport_api/sample/ConsoleActivity.java",
		"/D/GitHub/EmbStd_STM32/RT-Thread/.gitignore",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/test.c",
		"/D/360云盘/文档/sdmt_com/smdt_com/src/android_serialport_api/sample/ConsoleActivity.java",
		"/D/360云盘/文档/sdmt_com/smdt_com/src/android_serialport_api/sample/SerialPortPreferences.java",
		"/D/360云盘/文档/sdmt_com/smdt_com/src/android_serialport_api/sample/Sending01010101Activity.java",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/project.uvproj",
		"/C/Documents and Settings/smit/桌面/application.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/w25qxx.c                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Ccomponents%5Cdevices%5Cspi_flash%5Cw25qxx.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/rtconfig.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/sdcard.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/lcd_a70.c                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Cbsp%5Cmini2440%5Clcd_a70.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/lcd_n35.c                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Cbsp%5Cmini2440%5Clcd_n35.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/devices/spi_flash/at45dbxx.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/examples/test/device_test.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/dfs/src/dfs_fs.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/dfs/filesystems/elmfat/dfs_elm.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/mini2440/lcd_a70.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/mini2440/lcd_n35.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/rt_stm32f10x_spi.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/dfs/filesystems/elmfat/ff.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/devices/spi_flash/sst25vfxx.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/rt_stm32f10x_spi.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/devices/spi_flash/w25qxx.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/mini2440/application.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/spi.h                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Ccomponents%5Cdrivers%5Cinclude%5Cdrivers%5Cspi.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/include/rtdef.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/include/rtthread.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/src/mem.c",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/dfs_uffs.c                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Ccomponents%5Cdfs%5Cfilesystems%5Cuffs%5Cdfs_uffs.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/drivers/include/drivers/spi.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/stm32f10x_it.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/board.h",
		"/D/Program Files/SublimeText2/Data/Packages/GBK Encoding Support/tmp/startup.c                D%3A%5CGitHub%5CEmbStd_STM32%5CRT-Thread%5Cbsp%5Cstm32f10x%5Cstartup.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/mini2440/sdcard.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/startup.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/external/libz/zutil.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/drivers/spi/spi_core.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/drivers/include/rtdevice.h",
		"/C/Documents and Settings/smit/桌面/carGpio.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/drivers/spi/spi_dev.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/pthreads/pthread_internal.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/devices/spi_flash/复件 sst25vfxx.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/devices/spi_flash/spi_flash.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/adc_stm32.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/gpio.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/msd.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/led.c",
		"/C/Documents and Settings/smit/桌面/tcc_ts_ak.c",
		"/C/Documents and Settings/smit/桌面/gpio.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c",
		"/C/Documents and Settings/smit/桌面/BootService/AndroidManifest.xml",
		"/C/Documents and Settings/smit/桌面/BootService/src/com/smdt/keyeventservice/ShellService.java",
		"/C/Documents and Settings/smit/桌面/BootService/src/com/smdt/keyeventservice/BootReceiver.java",
		"/C/Documents and Settings/smit/桌面/BootService/src/com/smdt/keyeventservice/Main.java",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/devices/i2c_flash/atc24xx.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c",
		"/D/GitHub/EmbStd_STM32/RT-Thread/bsp/stm32f10x/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h",
		"/D/GitHub/EmbStd_STM32/RT-Thread/components/drivers/i2c/i2c_core.c"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*h,*c",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*h",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*c,*h",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*h",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*.c,*h",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*.c",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*.h",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*.h,*.c",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*.h",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*.c,*.h",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,*.c",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread,-*.c",
			"D:\\GitHub\\EmbStd_STM32\\RT-Thread"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"IR_KEY_LED_ID",
			"del",
			"IR_KEY_LED_ID",
			"delay",
			"rt_thread_delay",
			"check_pluse_array",
			"TIM_GetITStatus",
			"TIM_GetCapture2",
			"TIM_ICPolarity",
			"TIM_GetCapture",
			"RCC_PCLK1Config",
			"RCC_PLLConfig",
			"TIM_TimeBaseInit",
			"INT8U",
			"EXTI_Init",
			"printf",
			"TIM2_IRQHandler",
			"TIM_IT_CC2",
			"lvds",
			"bPowerOn",
			"dev",
			"TIM_GetITStatus",
			"rem_encoder",
			"remote_deviation",
			"c1e979a1",
			"spi",
			"A10_PWR_CTL",
			"gpio_direction_output",
			"err_times",
			"led",
			"mkdir",
			"dfs_elm_mount",
			"RT_USING_DFS_ELMFAT",
			"RT_USING_DFS_",
			"RT_USING_DFS_ELMFAT",
			"rt_memcpy",
			"w25qxx_read",
			"rt_memcpy",
			"memcpy",
			"mem",
			"memcopy",
			"block_buffer",
			"block_size",
			"rt_malloc",
			"AT45DB_flash_write_page_256",
			"CMD_ERASE_4K",
			"w25qxx_page_write",
			"AT45DB_flash_read_page_256",
			"w25qxx_flash_read",
			"bytes_per_sector",
			"GET_SECTOR_SIZE",
			"bytes_per_sector",
			"RT_USING_DFS_DEVFS",
			"RT_USING_DFS_ELMFAT",
			"RT_USING_DFS_DEVFS",
			"devfs_init",
			"mem_size_aligned",
			"list_mem",
			"xfer",
			"rt_device_register",
			"rt_spidev_device_init",
			"rt_device",
			"rt_spi_device",
			"user_data",
			"rt_spi_device",
			"w25qxx_init",
			"user_data",
			"cs",
			"stm32_spi_cs",
			"GPIO_ResetBits",
			"stm32_spi_cs",
			"GPIOA",
			"stm32_spi_cs",
			"GPIO_ResetBits",
			"IS_GPIO_ALL_PERIPH",
			"stm32f10x_gpio.c",
			"f_mkfs",
			"elm_result_to_dfs",
			"dfs_mkfs",
			"mkfs",
			"SPI_USE_DMA",
			"SPI File System init",
			"SDIO_IRQHandler",
			"RT_USING_DFS",
			"SDIO_IRQHandler",
			"STM32_USE_SDIO",
			"rt_hw_sdcard_init",
			"STM32_USE_SDIO",
			"rt_hw_msd_init",
			"msd_init",
			"STM32_USE_SDIO",
			"rt_hw_sdcard_init",
			"sdcard_init",
			"malloc",
			"malloc.h",
			"ff_wtoupper",
			"dfs_init",
			"MTC_W25X10_BV",
			"MTC_W25Q32_BV",
			"MTC_W25Q16_DW",
			"rt_spi_bus_attach_device",
			"rt_spi_bus_device_init",
			"rt_spidev_device_init",
			"spi_flash_sst25vfxx",
			"typedef",
			"RT_USING_I2C",
			"SDIO_Init",
			"RT_USING_DFS",
			"RT_USING_RTGUI",
			"STM32F10X_CL",
			"HSE_VALUE",
			"HSI_VALUE",
			"time",
			"ADC_RegularChannelConfig",
			"ADC_Channel_11",
			"rt_adc_control",
			"rt_device_read",
			"rt_device_control",
			"ADC_InitTypeDef",
			"ADC_GetConversionValue",
			"ADC_Cmd",
			"RCC_APB2PeriphClockCmd",
			"rt_rt_adc",
			"adc_bus_device",
			"RT_Device_Class_",
			"i2c",
			"adc",
			"i2c"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"uint8_t",
			"stm32_dbg",
			"rt_adc",
			"adc",
			"spi",
			"rt_kprintf",
			"I2C_BUS_NUM"
		],
		"reverse": true,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 8,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "bsp/stm32f10x/ir_stm32.c",
					"settings":
					{
						"buffer_size": 7490,
						"regions":
						{
						},
						"selection":
						[
							[
								3067,
								3067
							]
						],
						"settings":
						{
							"is_xml": false,
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1459.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/main.c.dump",
					"settings":
					{
						"buffer_size": 4027,
						"regions":
						{
						},
						"selection":
						[
							[
								2972,
								2984
							]
						],
						"settings":
						{
							"origin_encoding": "UTF-8",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1008.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/Printf.c.dump",
					"settings":
					{
						"buffer_size": 4913,
						"regions":
						{
						},
						"selection":
						[
							[
								4335,
								4350
							]
						],
						"settings":
						{
							"origin_encoding": "UTF-8",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1134.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/hw_config.c",
					"settings":
					{
						"buffer_size": 17285,
						"regions":
						{
						},
						"selection":
						[
							[
								8607,
								8624
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_endp.c",
					"settings":
					{
						"buffer_size": 4701,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"is_preview": true,
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_istr.c",
					"settings":
					{
						"buffer_size": 11358,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"is_preview": true,
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_prop.c",
					"settings":
					{
						"buffer_size": 13853,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"is_preview": true,
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_pwr.c",
					"settings":
					{
						"buffer_size": 7579,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"is_preview": true,
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/C/Users/Administrator/Desktop/STM32实现虚拟串口USB转串口，在开发板上进行了验证/Project/Virtual_COM_Port/src/usb_desc.c",
					"settings":
					{
						"buffer_size": 7169,
						"regions":
						{
						},
						"selection":
						[
							[
								7169,
								7169
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2376.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 9,
					"settings":
					{
						"buffer_size": 153354,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										183,
										198
									],
									[
										336,
										351
									],
									[
										497,
										512
									],
									[
										687,
										702
									],
									[
										860,
										875
									],
									[
										939,
										954
									],
									[
										1075,
										1090
									],
									[
										1168,
										1183
									],
									[
										1365,
										1380
									],
									[
										1571,
										1586
									],
									[
										1755,
										1770
									],
									[
										2070,
										2085
									],
									[
										2258,
										2273
									],
									[
										2538,
										2553
									],
									[
										2691,
										2706
									],
									[
										2826,
										2841
									],
									[
										2960,
										2975
									],
									[
										3104,
										3119
									],
									[
										3216,
										3231
									],
									[
										3359,
										3374
									],
									[
										3524,
										3539
									],
									[
										3655,
										3670
									],
									[
										3831,
										3846
									],
									[
										3971,
										3986
									],
									[
										4237,
										4252
									],
									[
										4459,
										4474
									],
									[
										4722,
										4737
									],
									[
										4807,
										4822
									],
									[
										5029,
										5044
									],
									[
										5347,
										5362
									],
									[
										5523,
										5538
									],
									[
										5699,
										5714
									],
									[
										5875,
										5890
									],
									[
										6051,
										6066
									],
									[
										6292,
										6307
									],
									[
										6502,
										6517
									],
									[
										6647,
										6662
									],
									[
										6897,
										6912
									],
									[
										7130,
										7145
									],
									[
										7194,
										7209
									],
									[
										7405,
										7420
									],
									[
										7615,
										7630
									],
									[
										7742,
										7757
									],
									[
										7855,
										7870
									],
									[
										8012,
										8027
									],
									[
										8289,
										8304
									],
									[
										8514,
										8529
									],
									[
										8702,
										8717
									],
									[
										8940,
										8955
									],
									[
										9157,
										9172
									],
									[
										9384,
										9399
									],
									[
										9483,
										9498
									],
									[
										9587,
										9602
									],
									[
										9692,
										9707
									],
									[
										9847,
										9862
									],
									[
										10001,
										10016
									],
									[
										10094,
										10109
									],
									[
										10244,
										10259
									],
									[
										10398,
										10413
									],
									[
										10543,
										10558
									],
									[
										10633,
										10648
									],
									[
										10724,
										10739
									],
									[
										10872,
										10887
									],
									[
										10998,
										11013
									],
									[
										11169,
										11184
									],
									[
										11268,
										11283
									],
									[
										11453,
										11468
									],
									[
										11549,
										11564
									],
									[
										11708,
										11723
									],
									[
										11793,
										11808
									],
									[
										11947,
										11962
									],
									[
										12096,
										12111
									],
									[
										12355,
										12370
									],
									[
										12515,
										12530
									],
									[
										12702,
										12717
									],
									[
										12805,
										12820
									],
									[
										12960,
										12975
									],
									[
										13059,
										13074
									],
									[
										13237,
										13252
									],
									[
										13423,
										13438
									],
									[
										13593,
										13608
									],
									[
										13744,
										13759
									],
									[
										13842,
										13857
									],
									[
										14028,
										14043
									],
									[
										14213,
										14228
									],
									[
										14365,
										14380
									],
									[
										14463,
										14478
									],
									[
										14706,
										14721
									],
									[
										14967,
										14982
									],
									[
										15139,
										15154
									],
									[
										15550,
										15565
									],
									[
										15763,
										15778
									],
									[
										15872,
										15887
									],
									[
										16102,
										16117
									],
									[
										16384,
										16389
									],
									[
										16537,
										16542
									],
									[
										16690,
										16695
									],
									[
										16847,
										16852
									],
									[
										17071,
										17076
									],
									[
										17285,
										17290
									],
									[
										17305,
										17310
									],
									[
										17434,
										17439
									],
									[
										17624,
										17629
									],
									[
										17637,
										17642
									],
									[
										17793,
										17798
									],
									[
										17896,
										17901
									],
									[
										18005,
										18010
									],
									[
										18144,
										18149
									],
									[
										18256,
										18261
									],
									[
										18423,
										18428
									],
									[
										18595,
										18600
									],
									[
										18674,
										18679
									],
									[
										18810,
										18815
									],
									[
										18903,
										18908
									],
									[
										19072,
										19077
									],
									[
										19238,
										19243
									],
									[
										19471,
										19476
									],
									[
										19697,
										19702
									],
									[
										19717,
										19722
									],
									[
										19864,
										19869
									],
									[
										20070,
										20075
									],
									[
										20083,
										20088
									],
									[
										20250,
										20255
									],
									[
										20344,
										20349
									],
									[
										20475,
										20480
									],
									[
										20570,
										20575
									],
									[
										20750,
										20755
									],
									[
										20883,
										20888
									],
									[
										21060,
										21065
									],
									[
										21298,
										21303
									],
									[
										21462,
										21467
									],
									[
										21570,
										21575
									],
									[
										21637,
										21642
									],
									[
										21786,
										21791
									],
									[
										21894,
										21899
									],
									[
										22090,
										22095
									],
									[
										22289,
										22294
									],
									[
										22373,
										22378
									],
									[
										22586,
										22591
									],
									[
										22651,
										22656
									],
									[
										22844,
										22849
									],
									[
										23000,
										23005
									],
									[
										23064,
										23069
									],
									[
										23128,
										23133
									],
									[
										23192,
										23197
									],
									[
										23257,
										23262
									],
									[
										23322,
										23327
									],
									[
										23488,
										23493
									],
									[
										23555,
										23560
									],
									[
										23622,
										23627
									],
									[
										23689,
										23694
									],
									[
										23756,
										23761
									],
									[
										23919,
										23924
									],
									[
										24115,
										24120
									],
									[
										24266,
										24271
									],
									[
										24454,
										24459
									],
									[
										24914,
										24919
									],
									[
										25338,
										25343
									],
									[
										25790,
										25795
									],
									[
										26214,
										26219
									],
									[
										26666,
										26671
									],
									[
										27090,
										27095
									],
									[
										27581,
										27586
									],
									[
										28082,
										28087
									],
									[
										28366,
										28371
									],
									[
										28663,
										28668
									],
									[
										28941,
										28946
									],
									[
										29354,
										29359
									],
									[
										29764,
										29769
									],
									[
										30069,
										30074
									],
									[
										30257,
										30262
									],
									[
										30445,
										30450
									],
									[
										30633,
										30638
									],
									[
										30821,
										30826
									],
									[
										30982,
										30987
									],
									[
										31092,
										31097
									],
									[
										31287,
										31292
									],
									[
										31298,
										31303
									],
									[
										31315,
										31320
									],
									[
										31467,
										31472
									],
									[
										31504,
										31509
									],
									[
										31592,
										31597
									],
									[
										31743,
										31748
									],
									[
										31754,
										31759
									],
									[
										31765,
										31770
									],
									[
										31772,
										31777
									],
									[
										31885,
										31890
									],
									[
										31934,
										31939
									],
									[
										31956,
										31961
									],
									[
										31967,
										31972
									],
									[
										31979,
										31984
									],
									[
										32145,
										32150
									],
									[
										32320,
										32325
									],
									[
										32459,
										32464
									],
									[
										32684,
										32689
									],
									[
										32823,
										32828
									],
									[
										33036,
										33041
									],
									[
										33265,
										33270
									],
									[
										33296,
										33301
									],
									[
										33378,
										33383
									],
									[
										33409,
										33414
									],
									[
										33562,
										33567
									],
									[
										33593,
										33598
									],
									[
										33816,
										33821
									],
									[
										33830,
										33835
									],
									[
										34145,
										34150
									],
									[
										34374,
										34379
									],
									[
										34405,
										34410
									],
									[
										34487,
										34492
									],
									[
										34518,
										34523
									],
									[
										34671,
										34676
									],
									[
										34702,
										34707
									],
									[
										34947,
										34952
									],
									[
										35080,
										35085
									],
									[
										35093,
										35098
									],
									[
										35227,
										35232
									],
									[
										35342,
										35347
									],
									[
										35502,
										35507
									],
									[
										35553,
										35558
									],
									[
										35604,
										35609
									],
									[
										35655,
										35660
									],
									[
										35706,
										35711
									],
									[
										35828,
										35833
									],
									[
										35912,
										35917
									],
									[
										36085,
										36090
									],
									[
										36220,
										36225
									],
									[
										36354,
										36359
									],
									[
										36498,
										36503
									],
									[
										36610,
										36615
									],
									[
										36779,
										36784
									],
									[
										36868,
										36873
									],
									[
										36936,
										36941
									],
									[
										37094,
										37099
									],
									[
										37217,
										37222
									],
									[
										37348,
										37353
									],
									[
										37524,
										37529
									],
									[
										37680,
										37685
									],
									[
										37793,
										37798
									],
									[
										38027,
										38032
									],
									[
										38067,
										38072
									],
									[
										38202,
										38207
									],
									[
										38289,
										38294
									],
									[
										38527,
										38532
									],
									[
										38567,
										38572
									],
									[
										38652,
										38657
									],
									[
										38874,
										38879
									],
									[
										39207,
										39212
									],
									[
										39241,
										39246
									],
									[
										39432,
										39437
									],
									[
										39466,
										39471
									],
									[
										39657,
										39662
									],
									[
										39691,
										39696
									],
									[
										39882,
										39887
									],
									[
										39916,
										39921
									],
									[
										40145,
										40150
									],
									[
										40179,
										40184
									],
									[
										40420,
										40425
									],
									[
										40720,
										40725
									],
									[
										41038,
										41043
									],
									[
										41065,
										41070
									],
									[
										41092,
										41097
									],
									[
										41132,
										41137
									],
									[
										41329,
										41334
									],
									[
										41495,
										41500
									],
									[
										41548,
										41553
									],
									[
										41624,
										41629
									],
									[
										41954,
										41959
									],
									[
										41965,
										41970
									],
									[
										42050,
										42055
									],
									[
										42061,
										42066
									],
									[
										42146,
										42151
									],
									[
										42157,
										42162
									],
									[
										42242,
										42247
									],
									[
										42253,
										42258
									],
									[
										42512,
										42517
									],
									[
										42527,
										42532
									],
									[
										42637,
										42642
									],
									[
										42655,
										42660
									],
									[
										43109,
										43114
									],
									[
										43381,
										43386
									],
									[
										43509,
										43514
									],
									[
										43663,
										43668
									],
									[
										43983,
										43988
									],
									[
										44111,
										44116
									],
									[
										44269,
										44274
									],
									[
										44613,
										44618
									],
									[
										44749,
										44754
									],
									[
										44957,
										44962
									],
									[
										45085,
										45090
									],
									[
										45243,
										45248
									],
									[
										45576,
										45581
									],
									[
										45712,
										45717
									],
									[
										46047,
										46052
									],
									[
										46120,
										46125
									],
									[
										46492,
										46497
									],
									[
										46533,
										46538
									],
									[
										46584,
										46589
									],
									[
										46829,
										46834
									],
									[
										46857,
										46862
									],
									[
										46969,
										46974
									],
									[
										47002,
										47007
									],
									[
										47014,
										47019
									],
									[
										47051,
										47056
									],
									[
										47075,
										47080
									],
									[
										47086,
										47091
									],
									[
										47232,
										47237
									],
									[
										47284,
										47289
									],
									[
										47672,
										47677
									],
									[
										47745,
										47750
									],
									[
										48117,
										48122
									],
									[
										48158,
										48163
									],
									[
										48209,
										48214
									],
									[
										48440,
										48445
									],
									[
										48468,
										48473
									],
									[
										48580,
										48585
									],
									[
										48613,
										48618
									],
									[
										48625,
										48630
									],
									[
										48662,
										48667
									],
									[
										48686,
										48691
									],
									[
										48697,
										48702
									],
									[
										48843,
										48848
									],
									[
										48895,
										48900
									],
									[
										49279,
										49284
									],
									[
										49352,
										49357
									],
									[
										49724,
										49729
									],
									[
										49765,
										49770
									],
									[
										49816,
										49821
									],
									[
										50045,
										50050
									],
									[
										50073,
										50078
									],
									[
										50185,
										50190
									],
									[
										50218,
										50223
									],
									[
										50230,
										50235
									],
									[
										50267,
										50272
									],
									[
										50291,
										50296
									],
									[
										50302,
										50307
									],
									[
										50448,
										50453
									],
									[
										50500,
										50505
									],
									[
										50883,
										50888
									],
									[
										50956,
										50961
									],
									[
										51328,
										51333
									],
									[
										51369,
										51374
									],
									[
										51420,
										51425
									],
									[
										51654,
										51659
									],
									[
										51682,
										51687
									],
									[
										51794,
										51799
									],
									[
										51827,
										51832
									],
									[
										51839,
										51844
									],
									[
										51876,
										51881
									],
									[
										51900,
										51905
									],
									[
										51911,
										51916
									],
									[
										52057,
										52062
									],
									[
										52109,
										52114
									],
									[
										52529,
										52534
									],
									[
										52544,
										52549
									],
									[
										52654,
										52659
									],
									[
										52672,
										52677
									],
									[
										53082,
										53087
									],
									[
										53341,
										53346
									],
									[
										53469,
										53474
									],
									[
										53611,
										53616
									],
									[
										53865,
										53870
									],
									[
										53993,
										53998
									],
									[
										54139,
										54144
									],
									[
										54399,
										54404
									],
									[
										54535,
										54540
									],
									[
										54770,
										54775
									],
									[
										55029,
										55034
									],
									[
										55157,
										55162
									],
									[
										55299,
										55304
									],
									[
										55553,
										55558
									],
									[
										55681,
										55686
									],
									[
										55827,
										55832
									],
									[
										56087,
										56092
									],
									[
										56223,
										56228
									],
									[
										56567,
										56572
									],
									[
										56582,
										56587
									],
									[
										56692,
										56697
									],
									[
										56710,
										56715
									],
									[
										57132,
										57137
									],
									[
										57386,
										57391
									],
									[
										57514,
										57519
									],
									[
										57668,
										57673
									],
									[
										57978,
										57983
									],
									[
										58106,
										58111
									],
									[
										58264,
										58269
									],
									[
										58582,
										58587
									],
									[
										58718,
										58723
									],
									[
										58916,
										58921
									],
									[
										59044,
										59049
									],
									[
										59202,
										59207
									],
									[
										59520,
										59525
									],
									[
										59656,
										59661
									],
									[
										60011,
										60016
									],
									[
										60026,
										60031
									],
									[
										60136,
										60141
									],
									[
										60154,
										60159
									],
									[
										60573,
										60578
									],
									[
										60838,
										60843
									],
									[
										60966,
										60971
									],
									[
										61117,
										61122
									],
									[
										61400,
										61405
									],
									[
										61528,
										61533
									],
									[
										61683,
										61688
									],
									[
										61988,
										61993
									],
									[
										62124,
										62129
									],
									[
										62368,
										62373
									],
									[
										62633,
										62638
									],
									[
										62761,
										62766
									],
									[
										62912,
										62917
									],
									[
										63195,
										63200
									],
									[
										63323,
										63328
									],
									[
										63478,
										63483
									],
									[
										63772,
										63777
									],
									[
										63908,
										63913
									],
									[
										64336,
										64341
									],
									[
										64494,
										64499
									],
									[
										64553,
										64558
									],
									[
										64593,
										64598
									],
									[
										64638,
										64643
									],
									[
										65054,
										65059
									],
									[
										65212,
										65217
									],
									[
										65271,
										65276
									],
									[
										65311,
										65316
									],
									[
										65356,
										65361
									],
									[
										65772,
										65777
									],
									[
										65930,
										65935
									],
									[
										65989,
										65994
									],
									[
										66029,
										66034
									],
									[
										66074,
										66079
									],
									[
										66490,
										66495
									],
									[
										66648,
										66653
									],
									[
										66707,
										66712
									],
									[
										66747,
										66752
									],
									[
										66792,
										66797
									],
									[
										67075,
										67080
									],
									[
										67148,
										67153
									],
									[
										67414,
										67419
									],
									[
										67450,
										67455
									],
									[
										67689,
										67694
									],
									[
										67762,
										67767
									],
									[
										68020,
										68025
									],
									[
										68056,
										68061
									],
									[
										68295,
										68300
									],
									[
										68368,
										68373
									],
									[
										68626,
										68631
									],
									[
										68662,
										68667
									],
									[
										68901,
										68906
									],
									[
										68974,
										68979
									],
									[
										69226,
										69231
									],
									[
										69261,
										69266
									],
									[
										69625,
										69630
									],
									[
										69687,
										69692
									],
									[
										69704,
										69709
									],
									[
										69766,
										69771
									],
									[
										69861,
										69866
									],
									[
										69956,
										69961
									],
									[
										70051,
										70056
									],
									[
										70645,
										70650
									],
									[
										71065,
										71070
									],
									[
										71513,
										71518
									],
									[
										71933,
										71938
									],
									[
										72381,
										72386
									],
									[
										72801,
										72806
									],
									[
										73290,
										73295
									],
									[
										73867,
										73872
									],
									[
										73903,
										73908
									],
									[
										74087,
										74092
									],
									[
										74210,
										74215
									],
									[
										74300,
										74305
									],
									[
										74381,
										74386
									],
									[
										74462,
										74467
									],
									[
										74543,
										74548
									],
									[
										74624,
										74629
									],
									[
										74705,
										74710
									],
									[
										74786,
										74791
									],
									[
										74867,
										74872
									],
									[
										74948,
										74953
									],
									[
										75029,
										75034
									],
									[
										75110,
										75115
									],
									[
										75191,
										75196
									],
									[
										75272,
										75277
									],
									[
										75353,
										75358
									],
									[
										75434,
										75439
									],
									[
										75515,
										75520
									],
									[
										75597,
										75602
									],
									[
										75603,
										75608
									],
									[
										75613,
										75618
									],
									[
										75638,
										75643
									],
									[
										75705,
										75710
									],
									[
										75730,
										75735
									],
									[
										75797,
										75802
									],
									[
										75822,
										75827
									],
									[
										75889,
										75894
									],
									[
										75914,
										75919
									],
									[
										75981,
										75986
									],
									[
										76006,
										76011
									],
									[
										76073,
										76078
									],
									[
										76098,
										76103
									],
									[
										76166,
										76171
									],
									[
										76191,
										76196
									],
									[
										76259,
										76264
									],
									[
										76284,
										76289
									],
									[
										76352,
										76357
									],
									[
										76377,
										76382
									],
									[
										76445,
										76450
									],
									[
										76470,
										76475
									],
									[
										76538,
										76543
									],
									[
										76563,
										76568
									],
									[
										76631,
										76636
									],
									[
										76656,
										76661
									],
									[
										76724,
										76729
									],
									[
										76749,
										76754
									],
									[
										76817,
										76822
									],
									[
										76842,
										76847
									],
									[
										76910,
										76915
									],
									[
										76935,
										76940
									],
									[
										77003,
										77008
									],
									[
										77028,
										77033
									],
									[
										77359,
										77364
									],
									[
										77643,
										77648
									],
									[
										77940,
										77945
									],
									[
										78218,
										78223
									],
									[
										78635,
										78640
									],
									[
										79080,
										79085
									],
									[
										79425,
										79430
									],
									[
										79468,
										79473
									],
									[
										79660,
										79665
									],
									[
										79775,
										79780
									],
									[
										80075,
										80080
									],
									[
										80114,
										80119
									],
									[
										80410,
										80415
									],
									[
										80617,
										80622
									],
									[
										80679,
										80684
									],
									[
										80702,
										80707
									],
									[
										81028,
										81033
									],
									[
										81297,
										81302
									],
									[
										81844,
										81849
									],
									[
										82306,
										82311
									],
									[
										82846,
										82851
									],
									[
										83004,
										83009
									],
									[
										83063,
										83068
									],
									[
										83103,
										83108
									],
									[
										83148,
										83153
									],
									[
										83564,
										83569
									],
									[
										83722,
										83727
									],
									[
										83781,
										83786
									],
									[
										83821,
										83826
									],
									[
										83866,
										83871
									],
									[
										84282,
										84287
									],
									[
										84440,
										84445
									],
									[
										84499,
										84504
									],
									[
										84539,
										84544
									],
									[
										84584,
										84589
									],
									[
										85000,
										85005
									],
									[
										85158,
										85163
									],
									[
										85217,
										85222
									],
									[
										85257,
										85262
									],
									[
										85302,
										85307
									],
									[
										85585,
										85590
									],
									[
										85658,
										85663
									],
									[
										85900,
										85905
									],
									[
										85928,
										85933
									],
									[
										86159,
										86164
									],
									[
										86232,
										86237
									],
									[
										86466,
										86471
									],
									[
										86494,
										86499
									],
									[
										86725,
										86730
									],
									[
										86798,
										86803
									],
									[
										87032,
										87037
									],
									[
										87060,
										87065
									],
									[
										87291,
										87296
									],
									[
										87364,
										87369
									],
									[
										87596,
										87601
									],
									[
										87624,
										87629
									],
									[
										87823,
										87828
									],
									[
										87875,
										87880
									],
									[
										87990,
										87995
									],
									[
										88289,
										88294
									],
									[
										88639,
										88644
									],
									[
										88664,
										88669
									],
									[
										88816,
										88821
									],
									[
										88961,
										88966
									],
									[
										89291,
										89296
									],
									[
										89660,
										89665
									],
									[
										90059,
										90064
									],
									[
										90422,
										90427
									],
									[
										90567,
										90572
									],
									[
										90937,
										90942
									],
									[
										91166,
										91171
									],
									[
										91226,
										91231
									],
									[
										91238,
										91243
									],
									[
										91302,
										91307
									],
									[
										91363,
										91368
									],
									[
										91374,
										91379
									],
									[
										91532,
										91537
									],
									[
										91650,
										91655
									],
									[
										91754,
										91759
									],
									[
										91865,
										91870
									],
									[
										91915,
										91920
									],
									[
										92012,
										92017
									],
									[
										92062,
										92067
									],
									[
										92112,
										92117
									],
									[
										92194,
										92199
									],
									[
										92342,
										92347
									],
									[
										92463,
										92468
									],
									[
										92571,
										92576
									],
									[
										92713,
										92718
									],
									[
										92820,
										92825
									],
									[
										92980,
										92985
									],
									[
										93231,
										93236
									],
									[
										93286,
										93291
									],
									[
										93317,
										93322
									],
									[
										93513,
										93518
									],
									[
										93621,
										93626
									],
									[
										93685,
										93690
									],
									[
										93885,
										93890
									],
									[
										94154,
										94159
									],
									[
										94366,
										94371
									],
									[
										94586,
										94591
									],
									[
										94828,
										94833
									],
									[
										95053,
										95058
									],
									[
										95253,
										95258
									],
									[
										95492,
										95497
									],
									[
										95596,
										95601
									],
									[
										95736,
										95741
									],
									[
										95808,
										95813
									],
									[
										95928,
										95933
									],
									[
										96036,
										96041
									],
									[
										96169,
										96174
									],
									[
										96316,
										96321
									],
									[
										96332,
										96337
									],
									[
										96479,
										96484
									],
									[
										96664,
										96669
									],
									[
										96874,
										96879
									],
									[
										97001,
										97006
									],
									[
										97114,
										97119
									],
									[
										97271,
										97276
									],
									[
										97523,
										97528
									],
									[
										97762,
										97767
									],
									[
										97989,
										97994
									],
									[
										98240,
										98245
									],
									[
										98414,
										98419
									],
									[
										98578,
										98583
									],
									[
										98711,
										98716
									],
									[
										98848,
										98853
									],
									[
										99018,
										99023
									],
									[
										99182,
										99187
									],
									[
										99443,
										99448
									],
									[
										99661,
										99666
									],
									[
										99792,
										99797
									],
									[
										99951,
										99956
									],
									[
										100134,
										100139
									],
									[
										100530,
										100535
									],
									[
										100845,
										100850
									],
									[
										101106,
										101111
									],
									[
										101534,
										101539
									],
									[
										101846,
										101851
									],
									[
										102182,
										102187
									],
									[
										102414,
										102419
									],
									[
										102794,
										102799
									],
									[
										103101,
										103106
									],
									[
										103148,
										103153
									],
									[
										103330,
										103335
									],
									[
										103341,
										103346
									],
									[
										103359,
										103364
									],
									[
										103504,
										103509
									],
									[
										103558,
										103563
									],
									[
										103591,
										103596
									],
									[
										103708,
										103713
									],
									[
										103912,
										103917
									],
									[
										103946,
										103951
									],
									[
										104254,
										104259
									],
									[
										104518,
										104523
									],
									[
										104747,
										104752
									],
									[
										104935,
										104940
									],
									[
										105195,
										105200
									],
									[
										105342,
										105347
									],
									[
										105517,
										105522
									],
									[
										105619,
										105624
									],
									[
										105839,
										105844
									],
									[
										105950,
										105955
									],
									[
										106009,
										106014
									],
									[
										106050,
										106055
									],
									[
										106226,
										106231
									],
									[
										106367,
										106372
									],
									[
										106536,
										106541
									],
									[
										106601,
										106606
									],
									[
										106646,
										106651
									],
									[
										106901,
										106906
									],
									[
										107018,
										107023
									],
									[
										107071,
										107076
									],
									[
										107131,
										107136
									],
									[
										107216,
										107221
									],
									[
										107347,
										107352
									],
									[
										107514,
										107519
									],
									[
										107647,
										107652
									],
									[
										107955,
										107960
									],
									[
										108277,
										108282
									],
									[
										108549,
										108554
									],
									[
										108865,
										108870
									],
									[
										109111,
										109116
									],
									[
										109202,
										109207
									],
									[
										109300,
										109305
									],
									[
										109684,
										109689
									],
									[
										109880,
										109885
									],
									[
										110233,
										110238
									],
									[
										110305,
										110310
									],
									[
										110508,
										110513
									],
									[
										110677,
										110682
									],
									[
										111128,
										111133
									],
									[
										111370,
										111375
									],
									[
										111396,
										111401
									],
									[
										111895,
										111900
									],
									[
										111976,
										111981
									],
									[
										112322,
										112327
									],
									[
										112698,
										112703
									],
									[
										112774,
										112779
									],
									[
										112851,
										112856
									],
									[
										113061,
										113066
									],
									[
										113452,
										113457
									],
									[
										113713,
										113718
									],
									[
										113740,
										113745
									],
									[
										114096,
										114101
									],
									[
										114249,
										114254
									],
									[
										114502,
										114507
									],
									[
										114563,
										114568
									],
									[
										114862,
										114867
									],
									[
										115161,
										115166
									],
									[
										115413,
										115418
									],
									[
										115746,
										115751
									],
									[
										115779,
										115784
									],
									[
										116085,
										116090
									],
									[
										116393,
										116398
									],
									[
										116616,
										116621
									],
									[
										116905,
										116910
									],
									[
										117165,
										117170
									],
									[
										117312,
										117317
									],
									[
										117487,
										117492
									],
									[
										117589,
										117594
									],
									[
										117809,
										117814
									],
									[
										117920,
										117925
									],
									[
										117979,
										117984
									],
									[
										118027,
										118032
									],
									[
										118202,
										118207
									],
									[
										118377,
										118382
									],
									[
										118543,
										118548
									],
									[
										118589,
										118594
									],
									[
										118667,
										118672
									],
									[
										118709,
										118714
									],
									[
										118971,
										118976
									],
									[
										119150,
										119155
									],
									[
										119203,
										119208
									],
									[
										119265,
										119270
									],
									[
										119386,
										119391
									],
									[
										119516,
										119521
									],
									[
										119683,
										119688
									],
									[
										119816,
										119821
									],
									[
										120087,
										120092
									],
									[
										120379,
										120384
									],
									[
										120617,
										120622
									],
									[
										120890,
										120895
									],
									[
										121152,
										121157
									],
									[
										121468,
										121473
									],
									[
										121714,
										121719
									],
									[
										121805,
										121810
									],
									[
										121903,
										121908
									],
									[
										122287,
										122292
									],
									[
										122483,
										122488
									],
									[
										122836,
										122841
									],
									[
										122908,
										122913
									],
									[
										123280,
										123285
									],
									[
										123572,
										123577
									],
									[
										123598,
										123603
									],
									[
										124097,
										124102
									],
									[
										124178,
										124183
									],
									[
										124524,
										124529
									],
									[
										124721,
										124726
									],
									[
										124745,
										124750
									],
									[
										124959,
										124964
									],
									[
										124986,
										124991
									],
									[
										125349,
										125354
									],
									[
										125502,
										125507
									],
									[
										125807,
										125812
									],
									[
										125886,
										125891
									],
									[
										125964,
										125969
									],
									[
										126257,
										126262
									],
									[
										126648,
										126653
									],
									[
										127015,
										127020
									],
									[
										127076,
										127081
									],
									[
										127315,
										127320
									],
									[
										127575,
										127580
									],
									[
										127712,
										127717
									],
									[
										127877,
										127882
									],
									[
										128110,
										128115
									],
									[
										128340,
										128345
									],
									[
										128553,
										128558
									],
									[
										128797,
										128802
									],
									[
										129003,
										129008
									],
									[
										129247,
										129252
									],
									[
										129427,
										129432
									],
									[
										129488,
										129493
									],
									[
										129729,
										129734
									],
									[
										129990,
										129995
									],
									[
										130259,
										130264
									],
									[
										130542,
										130547
									],
									[
										130589,
										130594
									],
									[
										130771,
										130776
									],
									[
										130782,
										130787
									],
									[
										130800,
										130805
									],
									[
										130939,
										130944
									],
									[
										130993,
										130998
									],
									[
										131026,
										131031
									],
									[
										131143,
										131148
									],
									[
										131358,
										131363
									],
									[
										131612,
										131617
									],
									[
										131945,
										131950
									],
									[
										131978,
										131983
									],
									[
										132284,
										132289
									],
									[
										132592,
										132597
									],
									[
										132815,
										132820
									],
									[
										133104,
										133109
									],
									[
										133364,
										133369
									],
									[
										133511,
										133516
									],
									[
										133686,
										133691
									],
									[
										133788,
										133793
									],
									[
										134008,
										134013
									],
									[
										134119,
										134124
									],
									[
										134178,
										134183
									],
									[
										134226,
										134231
									],
									[
										134401,
										134406
									],
									[
										134576,
										134581
									],
									[
										134736,
										134741
									],
									[
										134782,
										134787
									],
									[
										134860,
										134865
									],
									[
										134902,
										134907
									],
									[
										135158,
										135163
									],
									[
										135275,
										135280
									],
									[
										135334,
										135339
									],
									[
										135395,
										135400
									],
									[
										135510,
										135515
									],
									[
										135638,
										135643
									],
									[
										135805,
										135810
									],
									[
										135938,
										135943
									],
									[
										136240,
										136245
									],
									[
										136472,
										136477
									],
									[
										136745,
										136750
									],
									[
										137007,
										137012
									],
									[
										137323,
										137328
									],
									[
										137563,
										137568
									],
									[
										137654,
										137659
									],
									[
										137752,
										137757
									],
									[
										138136,
										138141
									],
									[
										138332,
										138337
									],
									[
										138679,
										138684
									],
									[
										138751,
										138756
									],
									[
										139117,
										139122
									],
									[
										139403,
										139408
									],
									[
										139429,
										139434
									],
									[
										139928,
										139933
									],
									[
										140009,
										140014
									],
									[
										140355,
										140360
									],
									[
										140552,
										140557
									],
									[
										140576,
										140581
									],
									[
										140784,
										140789
									],
									[
										140811,
										140816
									],
									[
										141174,
										141179
									],
									[
										141327,
										141332
									],
									[
										141632,
										141637
									],
									[
										141711,
										141716
									],
									[
										141789,
										141794
									],
									[
										142076,
										142081
									],
									[
										142467,
										142472
									],
									[
										142831,
										142836
									],
									[
										142892,
										142897
									],
									[
										143131,
										143136
									],
									[
										143368,
										143373
									],
									[
										143694,
										143699
									],
									[
										144067,
										144072
									],
									[
										144327,
										144332
									],
									[
										144569,
										144574
									],
									[
										144786,
										144791
									],
									[
										144967,
										144972
									],
									[
										145024,
										145029
									],
									[
										145123,
										145128
									],
									[
										145227,
										145232
									],
									[
										145332,
										145337
									],
									[
										145487,
										145492
									],
									[
										145641,
										145646
									],
									[
										145734,
										145739
									],
									[
										145884,
										145889
									],
									[
										146038,
										146043
									],
									[
										146160,
										146165
									],
									[
										146195,
										146200
									],
									[
										146285,
										146290
									],
									[
										146376,
										146381
									],
									[
										146524,
										146529
									],
									[
										146650,
										146655
									],
									[
										146821,
										146826
									],
									[
										146920,
										146925
									],
									[
										147105,
										147110
									],
									[
										147201,
										147206
									],
									[
										147360,
										147365
									],
									[
										147445,
										147450
									],
									[
										147599,
										147604
									],
									[
										147748,
										147753
									],
									[
										147964,
										147969
									],
									[
										148110,
										148115
									],
									[
										148177,
										148182
									],
									[
										148288,
										148293
									],
									[
										148355,
										148360
									],
									[
										148461,
										148466
									],
									[
										148570,
										148575
									],
									[
										148602,
										148607
									],
									[
										148692,
										148697
									],
									[
										148708,
										148713
									],
									[
										148791,
										148796
									],
									[
										148958,
										148963
									],
									[
										149061,
										149066
									],
									[
										149216,
										149221
									],
									[
										149315,
										149320
									],
									[
										149493,
										149498
									],
									[
										149679,
										149684
									],
									[
										149849,
										149854
									],
									[
										150000,
										150005
									],
									[
										150098,
										150103
									],
									[
										150284,
										150289
									],
									[
										150469,
										150474
									],
									[
										150621,
										150626
									],
									[
										150719,
										150724
									],
									[
										150962,
										150967
									],
									[
										151223,
										151228
									],
									[
										151395,
										151400
									],
									[
										151864,
										151869
									],
									[
										152263,
										152268
									],
									[
										152566,
										152571
									],
									[
										152784,
										152789
									],
									[
										152842,
										152847
									],
									[
										152926,
										152931
									],
									[
										153035,
										153040
									],
									[
										153265,
										153270
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								16700,
								16700
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"output_tag": 2,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 792.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 100.0
	},
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 289.0,
	"status_bar_visible": true
}
